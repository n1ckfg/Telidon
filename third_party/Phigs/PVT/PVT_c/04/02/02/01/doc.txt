TITLE: Polymarker  - individual attributes

MODULE#: 04.02.02.01

DESCRIPTION: This module tests the individual polymarker
attributes.  These values control the appearance of polymarkers
when they are under individual (as opposed to bundled) control.

SEMANTIC REQUIREMENTS:

*** *** ***   Polymarker attribute inquiry   *** *** ***

SR1.   If current element is marker type, marker size scale
factor, or polymarker colour index, then <inquire current element
type and size> returns the appropriate element type and size.
#F 303
#D 7.3.2.3.1 7.3.2.3.2 7.3.2.3.3
#S 4.4.4/29/5
#T P01/1 P01/3 P01/5

SR2.   If current element is marker type, marker size scale
factor, or polymarker colour index, then <inquire current element
content> returns the associated value for that element.
#F 304
#D 7.3.2.3.1 7.3.2.3.2 7.3.2.3.3
#S 4.4.4/29/5
#T P01/2 P01/4 P01/6

*** *** ***   Polymarker attribute traversal binding   *** *** ***

SR3.  Upon traversal of a "polymarker" or "polymarker 3" element,
the current marker type, marker size scale factor, and polymarker
colour index in the PTSL are bound to the resulting primitive.
#F 33 34 35
#D 3.2.2 3.2.3 3.2.4 7.3.1.3 7.3.1.4
#S 4.5.2/38/3 4.5.2/40/3
#T P02/1 P02/2 P02/3 P02/4 P02/6 P02/7 P02/8 P02/9 P02/10 P02/11 P02/12
   P03/1 P03/2 P03/3 P03/4 P03/5 P03/6 P03/7 P03/8 P03/9 P03/10 P04/1
   P04/2

*** ***   Marker type: element creation   *** ***

SR4.  <Set marker type> creates a "set marker type" element (in
the open structure), whose associated value is taken from the
function's parameter.
#F 33
#D 7.3.2.3.1
#S 4.4.1/23/1 4.5.2/38/3
#T P01/1 P01/2 P02/1 P02/2 P02/3 P02/4 P02/10 P03/1 P03/2 P03/3 P03/4

*** ***   Marker type: effect during traversal   *** ***

SR5.  Upon traversal of a "set marker type" element, the current
marker type entry in the PHIGS traversal state list (PTSL) is set
to the element's associated value.
#F 33
#D 3.2.2 7.3.2.3.1
#S 4.5.2/38/3
#T P02/1 P02/2 P02/3 P02/4 P02/10 P03/1 P03/2 P03/3 P03/4 P04/1

SR6.  When a polymarker is displayed, if its bound marker type is
available on the workstation and its bound marker type ASF is
INDIVIDUAL, then the appearance of the marker type agrees with
the documented specifications.
#F 33 264
#D 3.2.2 3.2.5 6.11.1.1 6.11.1.2
#S 4.5.2/39/7 4.5.4/44/2
#T P02/1 P02/2 P02/3 P02/4 P03/1 P03/2 P03/3 P03/4 P04/1

SR7.  When a polymarker is displayed, if its bound marker type is
not available on the workstation and its bound marker type ASF
is INDIVIDUAL, then marker type 3 (asterisk) is used to display
the polymarker.
#F 33 264
#D 3.2.2 3.2.5 6.11.1.1 6.11.1.2
#S 4.5.2/39/7 4.5.2/43/3
#T P02/2 P03/2

SR8.  When available on the workstation to which posted, marker
types 1 through 5 appear as dot, plus sign, asterisk, circle, and
diagonal cross, respectively.
#F
#D 6.11.1.1 6.11.1.2
#S 4.5.4/44/2
#T P02/1 P02/2 P03/1 P03/2

SR9.  When available on the workstation to which posted, marker
types greater than 5 appear as specified in the ISO register.
#F
#D 6.11.1.1 6.11.1.2
#S 4.1.2/15/2 4.5.4/44/2
#T P02/3 P03/3

SR10.  When available on the workstation to which posted, marker
types less than 1 appear as specified in the implementor
documentation.
#F
#D 6.11.1.1 6.11.1.2
#S 4.1.1/15/1 4.5.4/44/2
#T P02/4 P02/5 P03/4

*** ***   Marker type: network traversal   *** ***

SR11.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current marker type of the PTSL is set to 3.
#F
#D 2.11.2 3.2.2
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P04/1

SR12.  As part of the PTSL, the current marker type is saved (but
not changed) by execute structure and then, upon completion of
the sub-traversal of the invoked network, restored to the saved
value.
#F 113
#D 3.2.2
#S 4.4.3/28/1
#T P04/1

***   Marker size scale factor: element creation   ***

SR13.  <Set marker size scale factor> creates a "set marker size
scale factor" element (in the open structure), whose associated
value is taken from the function's parameter.
#F 34
#D 7.3.2.3.2
#S 4.4.1/23/1 4.5.2/38/3
#T P01/3 P01/4 P02/6 P02/7 P02/8 P02/9 P02/10 P03/5 P03/6 P03/7 P03/8

*** ***   Marker size scale factor: effect during traversal   *** ***

SR14.  Upon traversal of a "set marker size scale factor"
element, the current marker size scale factor entry in the PHIGS
traversal state list (PTSL) is set to the element's associated
value.
#F 34
#D 3.2.3 7.3.2.3.2
#S 4.5.2/38/3
#T P02/6 P02/7 P02/8 P02/9 P02/10 P03/5 P03/6 P03/7 P03/8 P04/1

SR15.  Except for marker type 1, when a polymarker is displayed, if
its logical marker size (= its bound marker size scale factor
times the workstation's nominal marker size) is available on the
workstation and its bound marker size scale factor ASF is
INDIVIDUAL, then the actual marker size agrees with the logical
marker size.
#F 34 264
#D 3.2.3 3.2.6 6.11.1.3 6.11.1.4 6.11.1.5 6.11.1.6
#S 4.5.2/39/7 4.5.4/44/3
#T P02/6 P03/5 P04/1

SR16.  Except for marker type 1, when a polymarker is displayed, if
its logical marker size is not available on the workstation and
its bound marker size scale factor ASF is INDIVIDUAL, then the
actual marker size is the nearest available to the logical marker
size.
#F 34 264
#D 3.2.3 3.2.6 6.11.1.3 6.11.1.4 6.11.1.5 6.11.1.6
#S 4.5.2/39/7 4.5.4/44/3
#T P02/7 P02/8 P02/9 P03/6 P03/7 P03/8

SR17. For marker type 1, when a polymarker is displayed, its logical
marker size is ignored and the polymarker is displayed as the
smallest displayable dot.
#F 33 34
#D 6.11.1.4 6.11.1.5 6.11.1.6
#S 4.5.4/44/3
#T P02/10

*** ***   Marker size scale factor: network traversal   *** ***

SR18.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current marker size scale factor of the PTSL is set to 1.0.
#F
#D 2.11.3 3.2.3
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P04/1

SR19.  As part of the PTSL, the current marker size scale factor
is saved (but not changed) by execute structure and then, upon
completion of the sub-traversal of the invoked network, restored
to the saved value.
#F 113
#D 3.2.3
#S 4.4.3/28/1
#T P04/1

***   Polymarker colour index: element creation   ***

SR20.   <Set polymarker colour index> creates a "set polymarker
colour index" element (in the open structure), whose associated
value is taken from the function's parameter.
#F 35
#D 7.3.2.3.3
#S 4.4.1/23/1 4.5.2/38/3
#T P01/5 P01/6 P02/11 P02/12 P03/9 P03/10

*** ***   Polymarker colour index: effect during traversal   *** ***

SR21.  Upon traversal of a "set polymarker colour index" element,
the current polymarker colour index entry in the PHIGS traversal
state list (PTSL) is set to the element's associated value.
#F 35
#D 3.2.4 7.3.2.3.3
#S 4.5.2/38/3
#T P02/11 P02/12 P03/9 P03/10 P04/2

SR22.  When a polymarker is displayed, if its bound polymarker
colour index is defined on the workstation and its bound
polymarker colour index ASF is INDIVIDUAL, then the polymarker
colour index is realized as itself.
#F 35
#D 3.2.4 3.2.7 5.15.3.1 5.15.3.2
#S 4.5.2/39/7 4.5.12/63/4
#T P02/11 P03/9 P04/2

SR23.  When a polymarker is displayed, if its bound polymarker
colour index is not defined on the workstation and its bound
polymarker colour index ASF is INDIVIDUAL, then the polymarker
colour index is realized as number 1.
#F 35
#D 3.2.4 3.2.7 5.15.3.1 5.15.3.2
#S 4.5.2/39/7 4.5.2/43/3
#T P02/12 P03/10

*** ***   Polymarker colour index: network traversal   *** ***

SR24.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current polymarker colour index of the PTSL is set to 1.
#F
#D 2.11.4 3.2.4
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P04/2

SR25.  As part of the PTSL, the current polymarker colour index
is saved (but not changed) by execute structure and then, upon
completion of the sub-traversal of the invoked network, restored
to the saved value.
#F 113
#D 3.2.4
#S 4.4.3/28/1
#T P04/2

 
LOCAL DICTIONARY:
 
  Functions ---
   33: psmk    <set marker type>
   34: psmksc  <set marker size scale factor>
   35: pspmci  <set polymarker colour index>
  113: pexst   <execute structure>
  264: pqpmf   <inquire polymarker facilities>
  303: pqcets  <inquire current element type and size>
  304: pqceco  <inquire current element content>
 
  Data Structures ---
  2  ...  phigs_description_table
  2.11 ...  default_polymarker_attributes
  2.11.2  ...  default_marker_type
  2.11.3  ...  default_marker_size_scale_factor
  2.11.4  ...  default_polymarker_colour_index
  3  ...  phigs_traversal_state_list
  3.2  ...  current_polymarker_attributes
  3.2.2  ...  current_marker_type
  3.2.3  ...  current_marker_size_scale_factor
  3.2.4  ...  current_polymarker_colour_index
  3.2.5  ...  current_marker_type_asf
  3.2.6  ...  current_marker_size_scale_factor_asf
  3.2.7  ...  current_polymarker_colour_index_asf
  5  ...  workstation_state_list
  5.15  ...  colour_entry
  5.15.3  ...  colour_table
  5.15.3.1  ...  colour_index
  5.15.3.2  ...  colour_specification
  6  ...  workstation_description_table
  6.11  ...  polymarker_entry
  6.11.1  ...  polymarker_facilities
  6.11.1.1  ...  number_of_available_marker_types
  6.11.1.2  ...  list_of_available_marker_types
  6.11.1.3  ...  number_of_available_marker_sizes
  6.11.1.4  ...  nominal_marker_size
  6.11.1.5  ...  minimum_marker_size
  6.11.1.6  ...  maximum_marker_size
  7  ...  structure_state_list
  7.3  ...  list_of_structure_elements
  7.3.1  ...  graphical_primitives
  7.3.1.3  ...  polymarker_3
  7.3.1.4  ...  polymarker
  7.3.2  ...  primitive_attributes
  7.3.2.3  ...  polymarker_attributes
  7.3.2.3.1  ...  marker_type
  7.3.2.3.2  ...  marker_size_scale_factor
  7.3.2.3.3  ...  polymarker_colour_index
 
LOCAL SUBROUTINES:

PMATTR tests polymarker attributes, either individually, using the
default values for the other attributes, or in combination, using
non-default values for the others.  It forms the body of P02 and
P03, since these are very similar except for varying the
attributes individually or in combination.

NDMW attempts to set marker size to a requested value, but not
near the default.

SHOWMW tests the rendering of a given marker size, and returns
the pass/fail result.  The actual marker is drawn using the
indicated marker type and color.  A polymarker of the expected
size is simulated with polyline.

RANMKT chooses a marker type at random from the three lists of
available marker types.

EXPPPM draws a polymarker with the expected marker type and
marker size.

LOCPPM draws a polymarker at the real y-location corresponding to
the integer index given in YLOC.

PMYXF returns the appropriate y-coordinate in WC for the ordered
polymarkers.


PROGRAM 1: Element creation and inquiring

CHARACTERISTICS: nnnn

OPERATOR SCRIPT: passive test.

DESIGN:

Use <inquire current element content> throughout to determine:
    celval = current element value as set by program
    recval = auxiliary element values implied by the standard's
             representation conventions.

Use <inquire current element type and size> throughout to determine:
    celsiz = current element size

*** *** *** *** ***   Marker type   *** *** *** *** ***
mtval = 17
<set marker type>:
    marker type = mtval

TEST: #SR 1 4
      "<Inquire current element type and size> should return
       marker type as the type of the created element and the
       appropriate element size."
<inquire current element type and size> for current element type
pass/fail depending on
  (current_element_type = marker type and
   celsiz               = values specified by the standard)

TEST: #SR 2 4
      "<Inquire current element content> should return the standard
       representation for the marker type value."
<inquire current element content> for current element representation
pass/fail depending on
  (celval = mtval and
   recval = auxiliary values specified by the standard)

*** *** *** *** ***   Marker size scale factor   *** *** *** *** ***
<set marker size scale factor>:
    marker size_scale_factor = 0.25

TEST: #SR 1 13
      "<Inquire current element type and size> should return marker
       size scale factor as the type of the created element and the
       appropriate element size."
<inquire current element type and size> for current element type
pass/fail depending on
  (current_element_type = marker size_scale_factor
   celsiz               = values specified by the standard)

TEST: #SR 2 13
      "<Inquire current element content> should return the standard
       representation for the marker size scale factor value."
<inquire current element content> for current element representation
pass/fail depending on
  (celval = 0.25 and
   recval = auxiliary values specified by the standard)

*** *** *** *** ***   Polymarker colour index   *** *** *** *** ***
<set polymarker colour index>:
    polymarker_colour_index = 2

TEST: #SR 1 20
      "<Inquire current element type and size> should return
       polymarker colour index as the type of the created element
       and the appropriate element size."
<inquire current element type and size> for current element type
pass/fail depending on
  (current_element_type = polymarker_colour_index
   celsiz               = values specified by the standard)

TEST: #SR 2 20
      "<Inquire current element content> should return the standard
       representation for the polymarker colour index value."
<inquire current element content> for current element representation
pass/fail depending on
  (celval = 2 and
   recval = auxiliary values specified by the standard)

END PROGRAM 1


PROGRAM 2: Appearance of individual attributes

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

MANDATORY MARKER TYPES: This screen should display examples of
each of the mandatory marker types actually supported by the
implementation.  You should not consider whether all 5 are
present, but simply whether each marker type is recognizable from
the verbal description.  Enter a list of integers which identify
the marker types in the same order as they appear in the prompt.

UNSUPPORTED MARKER TYPES: This screen should display several
asterisks and one non-asterisk marker.  Identify the non-asterisk
marker.

NON-MANDATORY REGISTERED MARKER TYPES: This screen displays a
sample of supported registered marker types (at most 8).  For
each displayed marker, look up its marker type identifier in the
ISO register and verify that the actual appearance of the marker
agrees with the ISO specification.

IMPLEMENTOR DEFINED MARKER TYPES: This screen displays a sample of
implementor defined marker types (at most 8).  For each displayed
marker, look up its marker type identifier in the implementor's
documentation and verify that the actual appearance of the marker
agrees with the specification.

COMPLETE DOCUMENTATION FOR IMPLEMENTOR MARKER TYPES: No associated
picture.  Verify that all the entries in the list of available
marker types for this workstation type are documented by the
implementor.  The list may be a subset of the documented
marker types.

VARIOUS MARKER SIZE SCALE FACTORS: Normally, several pairs of
plus signs are drawn.  Identify the pair (only one) where both
markers (plus sign) are the same size.  In case the marker size
is too large for several to fit on the screen, only one is drawn
and its size must fit within those of the surrounding dotted
circles.  Since this is centered on the screen it may (validly)
overlap the dialog area.

POSITIVE MARKER SIZE BELOW MINIMUM: as above, for VARIOUS MARKER
SIZE SCALE FACTORS.

NEGATIVE MARKER SIZE: as above, for VARIOUS MARKER SIZE SCALE
FACTORS.

POSITIVE MARKER SIZE ABOVE MAXIMUM: as above, for VARIOUS MARKER
SIZE SCALE FACTORS.

MARKER SIZE OF MARKER TYPE 1: This screen displays several dots
to the right of a vertical line and one dot, the reference dot,
to the left of the line.  Count up and report the number of dots
(on the right) which are the same size as the reference dot.

DEFINED POLYMARKER COLOR INDICES: All markers but one are drawn in
the background color.  Identify the single marker drawn in the
default foreground color.

UNDEFINED POLYMARKER COLOR INDICES: A star is drawn with several
markers beneath it.  Normally, all of these will be the
same color as the star.  Count up and report the number of markers
which match the star in color.


DESIGN:

use <inquire polymarker facilities> to determine:
  nummt  = number of marker types
  lavsmt = list of available standard marker types
  lavrmt = list of available registered (non-mandatory) marker types
  lavimt = list of available implementor-defined marker types
           (may be derived directly from marker type value, if
            reported number of marker types < 0)
  nummw  = number of available marker-sizes
  nommw  = nominal marker-size (DC)
  minmw,maxmw = minimum,maximum marker-size (DC)

*** *** ***   1. marker type

Use default background color=0, foreground=1

Display in random order all marker types in lavsmt

TEST: #SR 3 4 5 6 8
      "The mandatory marker types (1-5) should be recognizable from
       their standard description."

OPQA/MANDATORY MARKER TYPES: List, in order, the numeric labels
  for marker types: dot, plus sign, asterisk, circle, diagonal
  cross.
pass/fail depending on (all displayed marker types correctly identified)

lunsup = list of (mostly) unsupported marker types, contains:
  a negative unsupported type, if available
  a positive unsupported type
  0, if not supported
  3,
  2,4, or 5 if supported (the non-asterisk, non-dot one)

if (2,4,5 not available) then
   goto end_asterisk
endif

Display in random order marker types from lunsup

TEST: #SR 3 4 5 6 7 8
      "Unavailable marker types should be displayed as marker type
       number 3."

OPQA/UNSUPPORTED MARKER TYPES: Which marker is NOT an asterisk?
pass/fail depending on (the non-asterisk marker type (2,4, or 5) selected)

end_asterisk:

regdx = size of lavrmt
if regdx < 1 skip to neg_type

if regdx < 9
   mardis = markers to be displayed = all marker types in lavrmt
else
   mardis = markers to be displayed = 8 marker types randomly selected
                                      from lavrmt
endif

display in order and label all marker types in mardis

TEST: #SR 3 4 5 6 9
      "The registered non-mandatory marker types (> 5) should
       agree with their registered description."

OPQA/NON-MANDATORY REGISTERED MARKER TYPES: Is each marker type
  depicted according to its numeric identifier's specification in
  the ISO register?
pass/fail depending on (operator responds "yes")

neg_type:

impdx = size of lavimt
if impdx < 1 skip to end_marker type

if impdx < 9
   mardis = markers to be displayed = all marker types in lavimt
else
   mardis = markers to be displayed = 8 marker types randomly selected
                                    from lavimt
endif
display in order and label all marker types in mardis

TEST: #SR 3 4 5 6 10
      "Implementor-defined marker types (< 1) should agree with the
       descriptions supplied by the implementor."

OPQA/IMPLEMENTOR DEFINED MARKER TYPES: Is each marker type
  depicted according to its numeric identifier's specification in
  the implementor documentation?
pass/fail depending on (operator responds "yes")

if (impdx <= 8 or nummt < 0) then
   either all implementor marker types already shown or
   marker type appearance derived directly from value - skip test
   goto end_marker type
endif

TEST: #SR 10
      "All reported implementor-defined marker types available for a
       given workstation type should be documented by the
       implementor."

OPQA/COMPLETE DOCUMENTATION FOR IMPLEMENTOR MARKER TYPES: Are all
  these reportedly available marker types documented by the
  implementor: <lavimt> ?
pass/fail depending on (operator responds "yes")

end_marker type:

*** *** ***   2. marker size scale factor

from dialog common:
  wcpdc  = WC unit / DC unit
  qvis   = minimum distinguishable length in DC-units

Are there at least two visually distinguishable marker sizes?
if (nummw .eq. 1)           or
   (maxmw <= 1.02 * minmw)  or
   (maxmw-minmw < qvis)    then
   only one distinguishable:
   tstmw1 = first marker size to be tested = maxmw
   tstmw2 = last marker size to be tested = tstmw1
   mult = 2
else
   tstmw1 = first marker size to be tested = minmw
   tstmw2 =  last marker size to be tested = maxmw
   if (nummw .eq. 0) then
      continuous range of marker sizes available - take 4
         geometric steps
      mult = 0.9999 * ((tstmw2/tstmw1) ** 0.25)
   else
      discrete set of marker sizes available - test min/max only
      mult = 0.9999 * (tstmw2/tstmw1)
   endif
endif

numpas = 0 = number of tests passed so far
thismw = tstmw1

loop thru various marker sizes
next_mw:
OPQA/VARIOUS MARKER SIZE SCALE FACTORS: invoke SHOWMW subroutine to
  test requested marker size = thismw
        expected marker size = thismw
if abort indicated
   if (numpas < 2) then
      message about marker size too big for the screen
      goto min_max_coerce
   else
      goto do_test_msg
   endif
elseif failure indicated
   numpas = 0
   goto do_tst_msg
endif

numpas = numpas+1
set up for next marker size to be tested:
thismw = thismw * mult
if thismw <= tstmw2 goto next_mw

do_tst_msg:
TEST: #SR 3 13 14 15
      "Available marker size scale factors should control the
       realized size of a polymarker."
pass/fail depending on (numpas > 0)

min_max_coerce:

TEST: #SR 3 13 14 16
      "A requested positive marker size scale factor below the
       minimum available should be realized as the minimum."
OPQA/POSITIVE MARKER SIZE BELOW MINIMUM: invoke subroutine SHOWMW
  to test requested marker size = minmw/2
          expected marker size = minmw
pass/fail depending on return code from SHOWMW

TEST: #SR 3 13 14 16
      "A requested negative marker size scale factor should be
       realized as the minimum."
OPQA/NEGATIVE MARKER SIZE: invoke subroutine SHOWMW to test
  requested marker size = -maxmw-100
  expected marker size = minmw
pass/fail depending on return code from SHOWMW

OPQA/POSITIVE MARKER SIZE ABOVE MAXIMUM: invoke subroutine SHOWMW
  to test requested marker size = maxmw*2
          expected marker size = maxmw
if abort indicated
   message about marker size too big for the screen
else
   TEST: #SR 3 13 14 16
         "A requested marker size scale factor above the maximum
          available should be realized as the maximum."
   pass/fail depending on return code from SHOWMW
endif

*** *** *** marker type 1

set marker type = 1

nummar = number of markers to be drawn = random integer from 3 to 7
lmssf = list of marker sizes, contains:
   minmw/2, maxmw*2, -2.76, (minmw+maxmw)/2, minmw, maxmw, nommw

draw reference dot and vertical line separator

for ix = 1 to nummar
   draw marker with marker size = lmssf(ix)
next ix

TEST: #SR 3 4 5 13 14 17
      "Marker type 1 should be rendered as the smallest
       displayable dot, regardless of the marker size scale
       factor value."

OPQA/MARKER SIZE OF MARKER TYPE 1: How many dots to the right of
  the vertical line are the same size as the dot to the left of the
  line?
pass/fail depending on (number of dots = nummar)

*** *** ***   3. polymarker color index

TEST: #SR 3 20 21 22
      "A defined polymarker color index should cause the addressed
       entry in the color table to be used when rendering a
       polymarker."

bckcol = background color = realized color spec for entry #0
forcol = foreground color = realized color spec for entry #1

szcolt = maximum size of color table (including entry #0)
nummar = number of markers to be drawn = min(8, szcolt)
mkcol  = random permutation of #0,#1, and nummar-2 random choices
         from entries #2 to #szcolt-1
visdx = from mkcol, randomly select an entry to be made visible
        but not the one that contains 0, since this may not be
        re-settable.

for ix = 1 to nummar
   set entry mkcol(ix) to bckcol
   draw marker #ix with polymarker colour index = mkcol(ix), and label it
next ix

set entry mkcol(visdx) to forcol

OPQA/DEFINED POLYMARKER COLOR INDICES: Which marker is visible?
pass/fail depending on (response = marker colored by visdx)

end_def_col:

TEST: #SR 3 20 21 23
      "An undefined polymarker color index should cause entry
       number 1 in the color table to be used when rendering
       a polymarker."

set entry #1 in color table opposite from BCKCOL
set entry #1 different from FORCOL - make sure undefined default
  to *current* color-rep of #1, not just a predefined color.

u1,u2,u3 = 3 undefined, positive color indices - all greater
  than maximum defined entry in color table
expmct = number of explicit markers of color #1 = random integer
   from 0 to 4

draw star with color #1

display interleaved:
  three markers of color u1,u2,u3,
  explct markers of color #1

OPQA/UNDEFINED POLYMARKER COLOR INDICES: How many markers are the
  same color as the star?
pass/fail depending on response = 3+explct

END PROGRAM 2

PROGRAM 3: Combinations of individual attributes

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

MANDATORY MARKER TYPES: This screen should display examples of
each of the mandatory marker types actually supported by the
implementation.  You should not consider whether all 5 are
present, but simply whether each marker type is recognizable from
the verbal description.  Enter a list of integers which identify
the marker types in the same order as they appear in the prompt.

UNSUPPORTED MARKER TYPES: This screen should display several
asterisks and one non-asterisk marker.  Identify the non-asterisk
marker.

NON-MANDATORY REGISTERED MARKER TYPES: This screen displays a
sample of supported registered marker types (at most 8).  For
each displayed marker, look up its marker type identifier in the
ISO register and verify that the actual appearance of the marker
agrees with the ISO specification.

IMPLEMENTOR DEFINED MARKER TYPES: This screen displays a sample
of implementor defined marker types (at most 8).  For each
displayed marker, look up its marker type identifier in the
implementor's documentation and verify that the actual appearance
of the marker agrees with the specification.

VARIOUS MARKER SIZE SCALE FACTORS: Normally, several pairs of
markers, one actual, one simulated (type o, *, or +) are drawn.
Identify the pair (only one) where both markers are the same
size.  The simulated and actual types need not match exactly in
appearance, especially in the case of an asterisk, but the
diameters should be the same.  In case the marker size is too
large for several to fit on the screen, only one is drawn and its
size must fit within those of the surrounding dotted circles.
Since this is centered on the screen it may (validly) overlap the
dialog area.

POSITIVE MARKER SIZE BELOW MINIMUM: as above, for VARIOUS MARKER
SIZE SCALE FACTORS.

NEGATIVE MARKER SIZE: as above, for VARIOUS MARKER SIZE SCALE
FACTORS.

POSITIVE MARKER SIZE ABOVE MAXIMUM: as above, for VARIOUS MARKER
SIZE SCALE FACTORS.

DEFINED POLYMARKER COLOR INDICES: All markers but one are drawn
in the background color.  Identify the single marker drawn in the
default foreground color.

UNDEFINED POLYMARKER COLOR INDICES: A star is drawn with several
markers beneath it.  Normally, all of these will be the same
color as the star.  Count up and report the number of markers
which match the star in color.


DESIGN:

use <inquire polymarker facilities> to determine:
  nummt  = number of marker types
  lavsmt = list of available standard marker types
  lavrmt = list of available registered (non-mandatory) marker types
  lavimt = list of available implementor-defined marker types
           (may be derived directly from marker type value, if reported
            number of marker types < 0)
  nummw  = number of available marker-sizes
  nommw  = nominal marker-size (DC)
  minmw,maxmw = minimum,maximum marker-size (DC)

*** *** ***   1. marker type

call NDMW to set marker size to a non-default value, preferably
   half the distance between markers to be displayed
Display in random order all marker types in lavsmt, with
   colors drawn randomly from foreground colors

TEST: #SR 3 4 5 6 8
      "The mandatory marker types (1-5) should be recognizable from
       their standard description, even when a non-default marker
       size or color is used."

OPQA/MANDATORY MARKER TYPES: List, in order, the numeric labels
  for marker types: dot, plus sign, asterisk, circle, diagonal
  cross.
pass/fail depending on (all displayed marker types correctly identified)

lunsup = list of (mostly) unsupported marker types, contains:
  a negative unsupported type, if available
  a positive unsupported type
  0, if not supported
  3,
  2,4, or 5 if supported (the non-asterisk, non-dot one)

if (2,4,5 not available) then
   goto end_asterisk
endif

call NDMW to set marker size to a non-default value, preferably
   half the distance between markers to be displayed
Display in random order all marker types in lunsup, with
   colors drawn randomly from foreground colors

TEST: #SR 3 4 5 6 7 8
      "Unavailable marker types should be displayed as marker type
       number 3, even when a non-default marker size or color is used."

OPQA/UNSUPPORTED MARKER TYPES: Which marker is NOT an asterisk?
pass/fail depending on (the non-asterisk marker type (2,4, or 5) selected)

end_asterisk:

regdx = size of lavrmt
if regdx < 1 skip to neg_type

if regdx < 9
   mardis = markers to be displayed = all marker types in lavrmt
else
   mardis = markers to be displayed = 8 marker types randomly selected
                                      from lavrmt
endif

call NDMW to set marker size to a non-default value, preferably
   half the distance between markers to be displayed
Display in random order all marker types in mardis, with
   colors drawn randomly from foreground colors

TEST: #SR 3 4 5 6 9
      "The registered non-mandatory marker types (> 5) should
       agree with their registered description, even when a
       non-default marker size or color is used."

OPQA/NON-MANDATORY REGISTERED MARKER TYPES: Is each marker type
  depicted according to its numeric identifier's specification in
  the ISO register?
pass/fail depending on (operator responds "yes")

neg_type:

impdx = size of lavimt
if impdx < 1 skip to end_marker type

if impdx < 9
   mardis = markers to be displayed = all marker types in lavimt
else
   mardis = markers to be displayed = 8 marker types randomly selected
                                    from lavimt
endif

call NDMW to set marker size to a non-default value, preferably
   half the distance between markers to be displayed
Display in random order all marker types in mardis, with
   colors drawn randomly from foreground colors

TEST: #SR 3 4 5 6 10
      "Implementor-defined marker types (< 1) should agree with the
       descriptions supplied by the implementor, even when a
       non-default marker size or color is used."

OPQA/IMPLEMENTOR DEFINED MARKER TYPES: Is each marker type
  depicted according to its numeric identifier's specification in
  the implementor documentation?
pass/fail depending on (operator responds "yes")

end_marker type:

*** *** ***   2. marker size scale factor

from dialog common:
  wcpdc  = WC unit / DC unit
  qvis   = minimum distinguishable length in DC-units

Are there at least two visually distinguishable marker sizes?
if (nummw .eq. 1)             or
   (maxmw <= 1.02 * minmw)  or
   (maxmw-minmw < qvis)    then
   only one distinguishable:
   tstmw1 = first marker size to be tested = maxmw
   tstmw2 = last marker size to be tested = tstmw1
   mult = 2
else
   tstmw1 = first marker size to be tested = minmw
   tstmw2 =  last marker size to be tested = maxmw
   if (nummw .eq. 0) then
      continuous range of marker sizes available - take 4
         geometric steps
      mult = 0.9999 * ((tstmw2/tstmw1) ** 0.25)
   else
      discrete set of marker sizes available - test min/max only
      mult = 0.9999 * (tstmw2/tstmw1)
   endif
endif


numpas = 0 = number of tests passed so far
thismw = tstmw1

loop thru various marker sizes
next_mw:
next_mw:
ndmkst = randomly selected +,*,o marker type
pmcol  = randomly selected color index

OPQA/VARIOUS MARKER SIZE SCALE FACTORS: invoke SHOWMW subroutine to
  test requested marker size = thismw
       expected  marker size = thismw
       marker type           = ndmkst
       color index           = pmcol
if abort indicated
   if (numpas < 2) then
      message about marker size too big for the screen
      goto min_max_coerce
   else
      goto do_test_msg
   endif
elseif failure indicated
   numpas = 0
   goto do_tst_msg
endif

numpas = numpas+1
set up for next marker size to be tested:
thismw = thismw * mult
if thismw <= tstmw2 goto next_mw

do_tst_msg:
TEST: #SR 3 13 14 15
      "Available marker size scale factors should control the
       realized size of a polymarker, even when a non-default
       marker type or color is used."
pass/fail depending on (numpas > 0)

min_max_coerce:

TEST: #SR 3 13 14 16
      "A requested positive marker size scale factor below the
       minimum available should be realized as the minimum,
       even when a non-default marker type or color is used."

ndmkst = randomly selected +,*,o marker type
pmcol  = randomly selected color index

OPQA/POSITIVE MARKER SIZE BELOW MINIMUM: invoke subroutine SHOWMW
  to test requested marker size = minmw/2
          expected  marker size = minmw
          marker type           = ndmkst
          color index           = pmcol
pass/fail depending on return code from SHOWMW

TEST: #SR 3 13 14 16
      "A requested negative marker size scale factor should be
       realized as the minimum, even when a non-default
       marker type or color is used."

ndmkst = randomly selected +,*,o marker type
pmcol  = randomly selected color index

OPQA/NEGATIVE MARKER SIZE: invoke subroutine SHOWMW to test
  requested marker size = -maxmw-100
  expected  marker size = minmw
  marker type           = ndmkst
  color index           = pmcol
pass/fail depending on return code from SHOWMW

ndmkst = randomly selected +,*,o marker type
pmcol  = randomly selected color index

OPQA/POSITIVE MARKER SIZE ABOVE MAXIMUM: invoke subroutine SHOWMW
  to test requested marker size = maxmw*2
          expected  marker size = maxmw
          marker type           = ndmkst
          color index           = pmcol
if abort indicate
   message about marker size too big for the scrren
else
   TEST: #SR 3 13 14 16
         "A requested marker size scale factor above the maximum
          available should be realized as the maximum, even when a
          non-default marker type or color is used."
   pass/fail depending on return code from SHOWMW
endif

color_indx:
*** *** ***   3. polymarker color index

TEST: #SR 3 20 21 22
      "A defined polymarker color index should cause the addressed
       entry in the color table to be used when rendering a
       polymarker, even when a non-default marker type or marker size
       is used."

bckcol = background color = realized color spec for entry #0
forcol = foreground color = realized color spec for entry #1

szcolt = maximum size of color table (including entry #0)
nummar = number of markers to be drawn = min(8, szcolt)
mkcol  = random permutation of #0,#1, and nummar-2 random choices
         from entries #2 to #szcolt-1
visdx = from mkcol, randomly select an entry to be made visible
        but not the one that contains 0, since this may not be
        re-settable.

call NDMw to set marker size to a non-default values, preferably
   half the distance between markers to be displayed
for ix = 1 to nummar
   set entry mkcol(ix) to bckcol
   draw marker #ix with polymarker colour index = mkcol(ix),
      and label it using markertype = random choice from lavsmt
      (but not dot), lavrmt, lavimt
next ix

set entry mkcol(visdx) to forcol

OPQA/DEFINED POLYMARKER COLOR INDICES: Which marker is visible?
pass/fail depending on (response = marker colored by visdx)

end_def_col:

TEST: #SR 3 20 21 23
      "An undefined polymarker color index should cause entry
       number 1 in the color table to be used when rendering
       a polymarker, even when a non-default marker type or marker
       size is used."

set entry #1 in color table opposite from BCKCOL
set entry #1 different from FORCOL - make sure undefined default
  to *current* color-rep of #1, not just a predefined color.

u1,u2,u3 = 3 undefined, positive color indices - all greater
  than maximum defined entry in color table
expmct = number of explicit markers of color #1 = random integer
   from 0 to 4

call NDMw to set marker size to a non-default values, preferably
   half the distance between markers to be displayed

draw star with color #1

display interleaved:
  three markers of color u1,u2,u3,
  explct markers of color #1, for each using marker type = random
     choice from lavsmt (but not dot), lavrmt, lavilt

OPQA/UNDEFINED POLYMARKER COLOR INDICES: How many markers are the
  same color as the star?
pass/fail depending on response = 3+explct

END PROGRAM 3


PROGRAM 4: Network inheritance and initialization

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

STRUCTURE NETWORK INHERITANCE FOR MARKER TYPE AND MARKER SIZE: This
screen displays several left-right pairs of polymarkers.  Make sure
that all pairs except one have matching marker types and marker sizes.
Identify the non-matching pair.

STRUCTURE NETWORK INHERITANCE FOR POLYMARKER COLOR INDEX: This
screen displays several left-right pairs of polymarkers.  Make sure
that all pairs except one have matching colors.  For monochrome
workstations, both the background and foreground colors must be
used, and so several markers will be drawn in the background color.
Identify the non-matching pair.

DESIGN:

*** *** ***   inheritance for marker type and marker size *** *** ***

from dialog common:
qvis  = minimum distinguishable length in DC-units

nolap = scale factor equivalent to .05 in WC
(should not exceed .05 to avoid overlap - distance between lines
 will be 1/15 = .06666)

get alternative marker size scale factor values:
altmw1 = min(max scale factor, nolap)
altmw2 = qvis / (nominal marker size)

if default (1.0) is near altmw1 or altmw2, set alternate so as to
maximize the smallest gap among altmw1, altmw2, and 1.0:

avg1 = (altmw1 + 1) / 2
avg2 = (altmw2 + 1) / 2
if (abs(altmw1-1) < abs(avg2-1)) then
   altmw1 = avg2
elseif (abs(altmw2-1) < abs(avg1-1)) then
   altmw2 = avg1
endif

set up PERM to randomize position of polymarkers

set up CSS:

Structure network #101 draws actual results in random order on
left side of picture.  Structure #105 draws expected results in
same random order on right side of picture, except for polymarker
14 which is deliberately drawn with different (i.e. incorrect)
attributes. This should be the only non-matching pair in the picture.

structure #101
polymarker 1 (order within traversal)
execute 102
polymarker 9
change-attributes: marker type=2, marker size=altmw1 (do not use type=1)
polymarker 10
set local transformation to make markers 11,12 distinguishable
  from 5,6
execute 104
re-set local transformation to identity
polymarker 13
polymarker 14
execute 105

structure #102
polymarker 2
change-attributes: marker type =5, marker size=altmw2
execute 103
polymarker 8

structure #103
polymarker 3
change-attributes: marker type=4, marker size=altmw1
polymarker 4
execute 104
polymarker 7

structure #104
polymarker 5 / 11
change-attributes: marker type=2, marker size=altmw2
polymarker 6 / 12

Expected attributes (except #14, whose actual marker type should be 2):

structure #105
polymarker   markertype  markersize-scale
----------   ---------   ----------------
01           3           1.0
02           3           1.0
03           5           altmw2
04           4           altmw1
05           4           altmw1
06           2           altmw2
07           4           altmw1
08           5           altmw2
09           3           1.0
10           2           altmw1
11           2           altmw1
12           2           altmw2
13           2           altmw1
14           4           altmw1

TEST: #SR 3 5 6 11 12 14 15 18 19
      "The marker type and marker size attributes for the polymarker
       primitive should be saved and restored by <execute
       structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR MARKER TYPE AND MARKER SIZE:
  which pair of markers does NOT match?
pass/fail depending on response = position of polymarker 14

*** *** ***   inheritance for polymarker color index   *** *** ***

call DISCOL to try to get 5 distinct foreground colors,
  returning fcol = actual number of foreground colors
if fcol = 1 (monochrome) then
   fcol = 2
   colind[0..1] = circular list of indices = [1,0]
else
   colind[0..fcol-1] = circular list of indices = [1,..,fcol]
endif
set up PERM to randomize position of polymarkers
cbase = 0

set up CSS:

Structure network #101 draws actual results in random order on
left side of picture.  Structure #105 draws expected results in
same random order on right side of picture, except for polymarker
14 which is deliberately drawn with different (i.e. incorrect)
attributes. This should be the only non-matching pair in the picture.

structure #101
set markertype = 3
set markersize = nolap (= .05 in WC)
polymarker 1 (order within traversal)
execute 102
polymarker 9
increment cbase
change-attributes: use colind(cbase mod fcol) for next color index
polymarker 10
set local transformation to make markers 11,12 distinguishable
  from 5,6
execute 104
re-set local transformation to identity
polymarker 13
polymarker 14
execute 105

structure #102
polymarker 2
increment cbase
change-attributes: use colind(cbase mod fcol) for next color index
execute 103
polymarker 8

structure #103
polymarker 3
increment cbase
change-attributes: use colind(cbase mod fcol) for next color index
polymarker 4
execute 104
polymarker 7

structure #104
polymarker 5 / 11
increment cbase
change-attributes: use colind(cbase mod fcol) for next color index
polymarker 6 / 12

Expected attributes (except #14, whose actual color should be
same as #13):
color index = colind(cbase mod fcol)

structure #105
polymarker    cbase        polymarker    cbase
----------    -----        ----------    -----
01            0            08            2
02            0            09            0
03            2            10            1
04            3            11            1
05            3            12            4
06            4            13            1
07            3            14            2

TEST: #SR 3 21 22 24 25
      "The polymarker color index attribute for the polymarker
       primitive should be saved and restored by <execute
       structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR POLYMARKER COLOR INDEX:
  which pair of markers does NOT match?
pass/fail depending on response = position of polymarker 14

END PROGRAM 4

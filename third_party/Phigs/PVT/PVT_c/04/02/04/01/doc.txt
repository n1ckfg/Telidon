TITLE: Annotation text - individual attributes

MODULE#: 04.02.04.01

DESCRIPTION: This module tests the individual annotation text
attributes.  These values control the appearance of annotation
text relative primitives when they are under individual (as
opposed to bundled) control.  In order to explain clearly the
effect of annotation text relative aspects, some of the SRs are
worded in terms of the order of their application. E.g.
annotation text relative alignment and annotation text character
up vector are described as if applied in that order. It is only
the final appearance of the annotation text relative primitive,
however, which is subject to test.

SEMANTIC REQUIREMENTS:

*** *** ***   Text Local Coordinates   *** *** ***

SR1.  The Text Local Coordinate (TLC) system represents an
unscaled, unrotated shift within the Normalized Projection
Coordinate (NPC) system, such that the TLC origin coincides with
the NPC annotation point.
#F 15 16
#D 7.3.1.7 7.3.1.8
#S 4.5.1/35/1 4.5.6/55/1
#T P03/6 P06/2 P06/3 P06/4 P06/5 P08/1 P08/2 P08/3 P08/4 P09/1 P09/2
   P10/2 P10/4
#C Since TLC is not rotated with respect to NPC, it follows that
the TLC text plane is parallel to the x-y plane in NPC space.

SR2.  The NPC annotation point is the transformed (from MC to
NPC) reference point plus the (NPC) annotation offset.
#F 15 16
#D 7.3.1.7 7.3.1.8
#S 4.5.6/55/1
#T P03/6 P06/2 P06/3 P06/4 P06/5 P08/1 P08/2 P08/3 P08/4 P09/1 P09/2
   P10/2 P10/4

*** ***   Annotation text attribute inquiry   *** ***

SR3.  If current element is annotation text character height,
annotation text path, annotation text alignment, annotation text
character up vector, or annotation style, then <inquire current
element type and size> returns the appropriate element type and
size.
#F 303
#D 7.3.2.5.1 7.3.2.5.2 7.3.2.5.3 7.3.2.5.4 7.3.2.5.5
#S 4.4.4/29/5
#T P01/1 P01/3 P01/5 P01/7 P01/9

SR4.  If current element is annotation text character height,
annotation text path, annotation text alignment, annotation text
character up vector, or annotation style, then <inquire current
element content> returns the associated value for that element.
#F 304
#D 7.3.2.5.1 7.3.2.5.2 7.3.2.5.3 7.3.2.5.4 7.3.2.5.5
#S 4.4.4/29/5
#T P01/2 P01/4 P01/6 P01/8 P01/10

***   Annotation text attribute traversal binding  ***

SR5.  Upon traversal of a "annotation text relative" or
"annotation text relative 3" element, the current text font, text
precision, character expansion factor, character spacing, text
colour index, annotation text character height, annotation text
path, annotation text alignment, annotation text character up
vector, and annotation style in the PTSL are bound to the
resulting primitive.
#F 36 37 38 39 40 45 46 47 48 49
#D 3.3.2 3.3.3 3.3.4 3.3.5 3.3.6
#D 3.4.1 3.4.2 3.4.5 3.4.6 3.4.7 3.4.8 7.3.1.7 7.3.1.8
#S 4.5.2/38/3 4.5.2/41/2
#T P02/1 P02/2 P02/3 P02/4 P02/5 P02/6 P03/1 P03/2 P03/3 P03/4 P03/5
   P03/6 P03/8 P04/5 P05/1 P05/2 P05/3 P06/1 P06/2 P06/3 P06/4 P06/5
   P07/1 P07/2 P08/1 P08/2 P08/3 P08/4 P09/1 P09/2 P10/2 P10/3 P10/4
   P10/5 P10/6 P11/1 P11/2 P11/3 P11/4

***   text font: effect during traversal   ***

SR6.  Upon traversal of a "set text font" element, the current
text font entry in the PHIGS traversal state list (PTSL) is set
to the element's associated value.
#F 36
#D 3.3.2 7.3.2.4.1
#S 4.5.2/38/3
#T P02/1 P02/2 P02/3 P02/4 P02/5 P02/6 P03/1 P03/2 P03/3 P03/4 P03/5
   P03/7 P03/8 P05/1

SR7.  Text fonts 1 and 2 both contain all the ASCII characters,
i.e. those defined within ANSI X3.4-1986.
#F
#D 2.7
#S 4.5.5/47/4 4.5.5/48/5
#T P02/1 P02/2 P02/3 P02/4 P03/6 P03/7 P04/5 P06/1

SR8.  Text fonts 1 and 2 are visually distinguishable.
#F
#D
#S 4.5.5/47/4 4.5.5/48/5
#T P02/5 P03/8

SR9.  For all text fonts, a character body in TLC, before
application of annotation text character up vector, is a
rectangle generally surrounding the character, aligned such that
the top, cap, half, base, and bottom lines are all parallel to
the TLC x-axis and the left, centre, and right lines are all
parallel to the TLC y-axis.
#F
#D
#S 4.5.5/48/6 4.5.5/48/7
#T P02/6 P03/5 P03/6 P04/4 P08/1 P08/2 P08/3 P08/4 P09/1 P09/2
#C A small part of a kerned character may lie slightly outside
its character body.

SR10.  All text fonts are either monospaced or proportionately
spaced.  All character bodies within a monospaced font have the
same font nominal height and the same font nominal width.  All
character bodies within a proportionately spaced font have the
same font nominal height.
#F
#D
#S 4.5.5/48/6
#T P02/6 P03/5 P03/6
#C In monospaced fonts, the nominal height need not equal the
nominal width.  Font nominal height and width is the size, in
TLC, of the character bodies of a given font as set by the
annotation text character height and width aspects, before the
application of other annotation text relative aspects and before
the effect of the workstation transformation.

SR11.  Text font 1 is monospaced.
#F
#D
#S 4.5.5/48/5 4.14/113/3
#T P02/6 P06/2 P06/3 P06/4 P06/5

SR12.  A text font identifier denotes the same text font for all
workstation types within a PHIGS implementation.
#F
#D 2.2 6.12.1.1 6.12.1.2
#S 4.5.5/48/5
#T P03/1 P03/2 P03/3 P03/4
#C While the same text font, such as Helvetica or Cyrillic, must
appear on all workstations, the aspect ratios of corresponding
characters may differ somewhat, according to 4.5.7/56/7.

SR13.  If a requested character in an annotation text relative
primitive is not available within the font, an implementation
dependent representation is generated to so indicate.
#F
#D
#S 4.5.5/47/4
#T P03/7

SR14.  When an annotation text relative primitive is displayed, if
its bound text font and text precision are available on the
workstation and its bound text font and text precision ASFs are
INDIVIDUAL, then the appearance of the text font agrees with the
implementor documentation and, if the text font is greater than
2, with the ISO register.
#F 36 266
#D 3.3.2 3.3.3 3.3.7 3.3.8 6.12.1.1 6.12.1.2
#S 4.1.1/15/1 4.1.2/15/2 4.5.2/39/7 4.5.5/44/10 4.5.5/47/4
#T P02/1 P02/2 P02/3 P02/4 P02/5 P03/1 P03/2 P03/3 P03/4 P05/1
#S 4.5.5/48/6 4.5.6/55/3
#C For registered fonts, the details of character shapes may be
set by the implementor, even though the basic character set is
specified.

SR15.  When an annotation text relative primitive is displayed, if
its bound text font and text precision are not both available on
the workstation and its bound text font and text precision ASFs
are INDIVIDUAL, then text font 1 (as documented by the
implementor) and text precision STRING are used to display the
primitive.
#F 36 266
#D 3.3.2 3.3.3 3.3.7 3.3.8 6.12.1.1 6.12.1.2
#S 4.5.2/39/7 4.5.2/43/3 4.5.5/44/10 4.5.6/55/3
#T P03/8

*** *** ***    text font: network traversal   *** *** ***

SR16.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current text font of the PTSL is set to 1.
#F
#D 2.12.2 3.3.2
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P05/1

SR17.  As part of the PTSL, the current text font is saved (but
not changed) by execute structure and then, upon completion of
the sub-traversal of the invoked network, restored to the saved
value.
#F 113
#D 3.3.2
#S 4.4.3/28/1
#T P05/1

***   Text precision   ***

SR18.  The valid values for text precision in <set text
precision> are STRING, CHAR, and STROKE.
#F 37
#D 7.3.2.4.2
#S 4.5.5/47/5
#T P02/1 P02/2 P02/3 P02/4 P02/5

***   Text precision: effect during traversal   ***

SR19.  Upon traversal of a "set text precision" element, the
current text precision entry in the PHIGS traversal state list
(PTSL) is set to the element's associated value.
#F 37
#D 3.3.3 7.3.2.4.2
#S 4.5.2/38/3
#T P02/1 P02/2 P02/3 P02/4 P02/5 P03/8 P05/1 P06/5 P08/1 P08/2 P08/3
   P08/4 P09/1 P09/2

SR20.  When an annotation text relative primitive is displayed, if
its bound text font and text precision are available on the
workstation and its bound text font and text precision ASFs are
INDIVIDUAL, then the appearance of the annotation text relative
primitive meets or exceeds the requirements of the bound text
precision.
#F 37 266
#D 3.3.2 3.3.3 3.3.7 3.3.8 6.12.1.1 6.12.1.2
#S 4.5.2/39/7 4.5.5/44/10 4.5.5/48/5 4.5.6/55/3
#T P04/4 P05/1
#C A workstation may use a higher text precision for displaying
annotation text relative than the one requested.  SR16 above
describes the effect of an unavailable font or precision.

SR21.  For text precision = STRING and CHAR, the annotation text
relative string is displayed with the appropriate text font and
the nearest DC annotation text character height and character
expansion factor available on the workstation.
#F 37
#D 6.13.1.1 6.13.1.2 6.13.1.3 6.12.1.6 6.12.1.7 6.12.1.8
#S 4.5.5/47/5 4.5.5/49/5 4.5.6/55/3
#T P03/2 P03/4 P04/4
#C In the case where STRING is used as a result of coercion from
an unavailable font and precision, then the actual font (1) may
differ from the requested font.  See SRs below for details of
coercion of annotation text character height and expansion
factor.  Since there is no perspective effect, all characters are
of the same height, and there is no distinction between the
effect of STRING and CHAR.

SR22.  For text precision = CHAR, character spacing and
annotation text alignment aspects are applied exactly.
#F 37
#D
#S 4.5.5/47/5 4.5.5/49/5 4.5.6/55/3
#T P04/4
#C See SRs below for details of coercion of annotation text
character height and expansion factor.

SR23.  For text precision = STROKE, annotation text relative is
displayed with all annotation text relative aspects applied
exactly.
#F 37
#D
#S 4.5.5/48/1 4.5.5/49/5 4.5.6/55/3
#T P02/6 P03/5 P03/6 P06/1 P06/2 P06/3 P06/4 P06/5 P08/1 P08/2 P08/3
   P08/4 P09/1 P09/2

***   Text precision: network traversal   ***

SR24.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current text precision of the PTSL is set to STRING.
#F
#D 2.12.3 3.3.3
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P05/1

SR25.  As part of the PTSL, the current text precision is saved
(but not changed) by execute structure and then, upon completion
of the sub-traversal of the invoked network, restored to the
saved value.
#F 113
#D 3.3.3
#S 4.4.3/28/1
#T P05/1

*** ***   Character expansion: effect during traversal   *** ***

SR26.  Upon traversal of a "set character expansion factor"
element, the current character expansion factor entry in the
PHIGS traversal state list (PTSL) is set to the element's
associated value.
#F 38
#D 3.3.4 7.3.2.4.3
#S 4.5.2/38/3
#T P04/5 P05/2 P06/2 P06/3 P06/4 P06/5

SR27.  The magnitude of the character expansion factor attribute
specifies the amount by which the font nominal width/height ratio
of individual TLC character bodies is multiplied to yield the
actual TLC width/height ratio.
#F 269
#D
#S 4.5.5/45/2 4.5.5/45/4 4.5.6/55/3 5.4.2/138/6
#T P02/6 P03/5 P04/4 P04/5 P05/2 P06/2 P06/3 P06/4 P06/5

SR28.  The requested DC character expansion factor equals the
requested TLC character expansion factor.
#F
#D
#S 4.5.6/55/1 4.7.6/90/6 4.7.6/91/9
#T P04/4 P06/2 P06/3 P06/4
#C True because TLC -> NPC and NPC -> DC are both transformations
with uniform scaling.

SR29.  When an annotation text relative primitive is displayed, if
its bound character expansion factor ASF is INDIVIDUAL, then the
actual DC character expansion factor used when displaying the
annotation text relative is the nearest available to the
requested DC character expansion factor.
#F 38 266
#D 3.3.4 3.3.9 6.12.1.6 6.12.1.7 6.12.1.8
#S 4.5.2/39/7 4.5.5/44/10 4.5.5/47/5 4.5.5/49/2 4.5.5/49/4
#T P04/4 P06/5
#S 4.5.6/55/3 5.4.2/138/6
#C Character expansion factor may be approximated only for STRING
or CHAR text precision; STROKE precision implies exact
realization.  See the SRs on text precision, above.  Of course,
by the above rule, if a requested expansion factor is available
on the workstation, then the result is exact for any precision.

*** ***   Character expansion: network traversal   *** ***

SR30.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current character expansion factor of the PTSL is set to 1.0.
#F
#D 2.12.4 3.3.4
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P05/2

SR31.  As part of the PTSL, the current character expansion
factor is saved (but not changed) by execute structure and then,
upon completion of the sub-traversal of the invoked network,
restored to the saved value.
#F 113
#D 3.3.4
#S 4.4.3/28/1
#T P05/2

*** ***   Character spacing: effect during traversal   *** ***

SR32.  Upon traversal of a "set character spacing" element, the
current character spacing entry in the PHIGS traversal state list
(PTSL) is set to the element's associated value.
#F 39
#D 3.3.5 7.3.2.4.4
#S 4.5.2/38/3
#T P05/2 P06/2 P06/3 P06/4 P06/5

SR33.  Character spacing specifies the TLC distance (positive) or
overlap (negative) between adjacent character bodies, expressed
in units of the font nominal annotation text character height.
#F 269
#D
#S 4.5.5/45/3 4.5.6/55/3
#T P02/6 P03/5 P05/2 P06/2 P06/3 P06/4 P06/5

SR34.  When an annotation text relative primitive is displayed and
its bound character spacing ASF is INDIVIDUAL, then the bound
character spacing is used when displaying the annotation text
relative.
#F 39
#D 3.3.5 3.3.10
#S 4.5.2/39/7 4.5.5/44/10 4.5.6/55/3
#T P06/2 P06/3 P06/4 P06/5
#C Character spacing may be approximated only for STRING
annotation text relative precision; CHAR or STROKE precision
implies exact realization.  See the SRs on text precision, above.

*** ***   Character spacing: network traversal   *** ***

SR35.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current character spacing of the PTSL is set to 0.0.
#F
#D 2.12.5 3.3.5
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P05/2

SR36.  As part of the PTSL, the current character spacing is
saved (but not changed) by execute structure and then, upon
completion of the sub-traversal of the invoked network, restored
to the saved value.
#F 113
#D 3.3.5
#S 4.4.3/28/1
#T P05/2

***   Text colour index: effect during traversal   ***

SR37.  Upon traversal of a "set text colour index" element, the
current text colour index entry in the PHIGS traversal state list
(PTSL) is set to the element's associated value.
#F 40
#D 3.3.6 7.3.2.4.5
#S 4.5.2/38/3
#T P05/3 P07/1 P07/2

SR38.  When annotation text relative is displayed, if its bound text
colour index is defined on the workstation and its bound text
colour index ASF is INDIVIDUAL, then the text colour index is
realized as itself.
#F 40
#D 3.3.6 3.3.11 5.15.3.1 5.15.3.2
#S 4.5.2/39/7 4.5.5/44/10 4.5.6/55/3 4.5.12/63/4
#T P05/3 P07/1

SR39.  When annotation text relative is displayed, if its bound text
colour index is not defined on the workstation and its bound text
colour index ASF is INDIVIDUAL, then the text colour index is
realized as number 1.
#F 40
#D 3.3.6 3.3.11 5.15.3.1 5.15.3.2
#S 4.5.2/39/7 4.5.2/43/3 4.5.5/44/10 4.5.6/55/3
#T P07/2

***   Text colour index: network traversal   ***

SR40.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current text colour index of the PTSL is set to 1.
#F
#D 2.12.6 3.3.6
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P05/3

SR41.  As part of the PTSL, the current text colour index is
saved (but not changed) by execute structure and then, upon
completion of the sub-traversal of the invoked network, restored
to the saved value.
#F 113
#D 3.3.6
#S 4.4.3/28/1
#T P05/3

***   Annotation text character height: element creation   ***

SR42.  <Set annotation text character height> creates a "set
annotation text character height" element (in the open
structure), whose associated value is taken from the function's
parameter.
#F 45
#D 7.3.2.5.1
#S 4.4.1/23/1 4.5.2/38/3
#T P01/1 P01/2 P04/5

*** ***   Annotation text Character Height Support   *** ***

SR43.  <Inquire annotation facilities> describes the realizable
annotation text character heights for a specified workstation
type, via the number of available character heights, minimum
character height and maximum character height.
#F 268
#D 6.13.1.1 6.13.1.2 6.13.1.3
#S n
#T P04/1 P04/2 P04/3

SR44.  The minimum and maximum annotation text character height
are both positive.
#F 268
#D 6.13.1.2 6.13.1.3
#S 6.7/322/1
#T P04/2

SR45.  All workstation types support at least one annotation text
character height for STRING and CHAR precisions.
#F 268
#D 6.13.1.1
#S 4.14/114/2 6.7/322/1
#T P04/3

SR46.  The range of character heights returned by <Inquire annotation
facilities> is for font 1.
#F 268
#D 6.13.1.2 6.13.1.3
#S n
#T P04/4

SR47.  The workstation supports a continuous range of character
heights for CHAR and STRING precision, if the number of available
character heights is 0.
#F 268
#D 6.13.1.1
#S 6.7/322/1
#T P04/3 P04/4

*** Annotation text character height: effect during traversal ***

SR48.  Upon traversal of a "set annotation text character height"
element, the current annotation text character height entry in
the PHIGS traversal state list (PTSL) is set to magnitude of the
element's associated value.
#F 45
#D 3.4.1 7.3.2.5.1
#S 4.5.2/38/3
#T P03/6 P04/5 P06/2 P06/3 P06/4 P06/5 P11/1

SR49.  The magnitude of the annotation text character height
attribute specifies, in TLC, the font nominal height (from
baseline to capline) of a capital letter.
#F 269
#D
#S 4.5.5/45/2 4.5.5/46/1 4.5.5/48/7 4.5.6/55/4 5.4.2/142/1
#T P02/6 P03/5 P03/6 P04/4 P04/5 P06/2 P06/3 P06/4 P06/5
#C Annotation text character height is measured in TLC, along the
annotation text character up vector.  Since TLC is unscaled from
NPC, the magnitude of annotation text character height may also
be treated as if in NPC.

SR50.  The font nominal width in TLC of a character within an
annotation text relative primitive is given by the font's
intrinsic width to height ratio for that character times the
magnitude of the annotation text character height.
#F
#D
#S 4.5.5/44/9 4.5.5/45/2 4.5.6/55/4 5.4.2/142/1
#T P02/6 P04/4 P06/2 P06/3 P06/4 P06/5
#C Since <set annotation text character height> also sets the
character width attribute, annotation text character height is in
effect a scaling factor for the entire character.

SR51.  The requested DC annotation text character height for a
character within a displayed annotation text relative string equals
the TLC character height as transformed by the workstation
transformation.
#F 45
#D 3.4.1
#S 4.5.5/48/7 4.5.5/49/5 4.5.6/55/1 4.5.6/55/4 4.7.6/90/6
#T P04/4 P06/2 P06/3 P06/4
#S 4.7.6/91/9
#C Since TLC -> NPC is unscaled, and NPC -> DC (workstation
transformation) does uniform scaling, only the latter affects the
DC size of the characters.

SR52.  When an annotation text relative primitive is displayed, the
actual DC annotation text character height is the nearest
available to the requested DC annotation text character height
resulting from its TLC bound annotation text character height
(after undergoing the workstation transformation).
#F 45 266
#D 3.4.1 6.13.1.1 6.13.1.2 6.13.1.3
#S 4.5.5/45/2 4.5.5/47/5 4.5.5/49/2 4.5.6/55/4 5.4.2/142/1
#T P04/4 P06/2 P06/3 P06/4 P06/5
#C See SRs above for derivation of requested DC annotation text
character height and width.  Annotation text character height may
be approximated only for STRING or CHAR text precision; STROKE
precision implies exact realization, as stated in the SRs on text
precision, above.  Of course, by the above rule, if a requested
height is available on the workstation, then the result is exact
for any precision.

***   Annotation text character height: network traversal   ***

SR53.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current annotation text character height and width of the PTSL
are set to 0.01.
#F
#D 2.13.1 3.4.1
#S 4.4.3/26/2 4.4.3/28/1 4.5.5/47/2 6.3/309/1
#T P11/1

SR54.  As part of the PTSL, the current annotation text character
height and width are saved (but not changed) by execute structure
and then, upon completion of the sub-traversal of the invoked
network, restored to the saved value.
#F 113
#D 3.4.1
#S 4.4.3/28/1
#T P11/1

*** ***   Annotation text path: element creation   *** ***

SR55.  <Set annotation text path> creates a "set annotation text
path" element (in the open structure), whose associated value is
taken from the function's parameter.
#F 47
#D 7.3.2.5.3
#S 4.4.1/23/1 4.5.2/38/3
#T P01/5 P01/6 P06/1

SR56.  The valid values for annotation text path in <set
annotation text path> are RIGHT, LEFT, UP, and DOWN.
#F 47
#D 7.3.2.5.3
#S 4.5.5/45/2 4.5.6/55/4
#T P01/6 P06/1 P08/1 P08/3

***   Annotation text path: effect during traversal   ***

SR57.  Upon traversal of a "set annotation text path" element,
the current annotation text path entry in the PHIGS traversal
state list (PTSL) is set to the element's associated value.
#F 47
#D 3.4.5 7.3.2.5.3
#S 4.5.2/38/3
#T P06/1 P06/2 P06/3 P06/4 P06/5 P08/1 P08/2 P08/3 P08/4 P09/1 P09/2
   P11/3

SR58.  The annotation text path specifies the writing direction
within the TLC x-y plane for the annotation text relative string
before application of the annotation text character up vector
attribute (i.e. the direction in which successive characters are
appended) as follows: RIGHT: positive x-axis, LEFT: negative
x-axis, UP: positive y-axis, DOWN: negative x-axis.
#F 47
#D
#S 4.5.5/45/2 4.5.6/55/4
#T P06/1 P06/2 P06/3 P06/4 P06/5 P08/1 P08/2 P08/3 P08/4 P09/1 P09/2
   P11/3
#C Only STROKE precision implies exact realization of annotation
text path.  See the SRs on text precision, above.

SR59.  For vertical annotation text paths (UP or DOWN), the
centrelines of the character bodies are aligned vertically within
the annotation text relative string before application of the
annotation text character up vector attribute.
#F 47
#D
#S 4.5.5/45/2 4.5.6/55/4
#T P06/3 P06/5 P09/2

SR60.  For horizontal annotation text paths (LEFT or RIGHT), the
baselines of the character bodies are aligned horizontally within
the annotation text relative string before application of the
annotation text character up vector attribute.
#F 47
#D
#S 4.5.5/45/2 4.5.6/55/4
#T P06/2 P06/4 P09/1

*** ***   Annotation text path: network traversal   *** ***

SR61.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current annotation text path of the PTSL is set to RIGHT.
#F
#D 2.13.5 3.4.5
#S 4.4.3/26/2 4.4.3/28/1 4.5.5/47/2 6.3/310/1
#T P11/3

SR62.  As part of the PTSL, the current annotation text path is
saved (but not changed) by execute structure and then, upon
completion of the sub-traversal of the invoked network, restored
to the saved value.
#F 113
#D 3.4.5
#S 4.4.3/28/1
#T P11/3

*** ***   Annotation text alignment: element creation   *** ***

SR63.  <Set annotation text alignment> creates a "set annotation
text alignment" element (in the open structure), whose associated
value is taken from the function's parameter.
#F 48
#D 7.3.2.5.4
#S 4.4.1/23/1 4.5.2/38/3
#T P01/7 P01/8 P08/1 P08/2 P08/3 P08/4

SR64.  The valid values in <set annotation text alignment> for
horizontal annotation text alignment are NORMAL, LEFT, CENTRE,
and RIGHT; for vertical annotation text alignment, NORMAL, TOP,
CAP, HALF, BASE, and BOTTOM.
#F 48
#D 7.3.2.5.4
#S 4.5.5/45/6 4.5.5/46/1 4.5.6/55/4
#T P01/8 P08/1 P08/2 P08/3 P08/4

***   Annotation text alignment: effect during traversal   ***

SR65.  Upon traversal of a "set annotation text alignment"
element, the current annotation text alignment entry in the PHIGS
traversal state list (PTSL) is set to the element's associated
value.
#F 48
#D 3.4.6 3.4.7 7.3.2.5.4
#S 4.5.2/38/3
#T P08/1 P08/2 P08/3 P08/4 P09/1 P09/2 P11/2

SR66.  The annotation text alignment specifies which horizontal
and vertical location within the annotation text relative
rectangle is to coincide with the TLC origin by shifting the
rectangle within the annotation text relative plane.  For all
annotation text paths, alignments LEFT, RIGHT, BOTTOM, and TOP
refer to the left, right, bottom, and top edges of the rectangle,
and CENTRE refers to the horizontal location midway between the
left and right edges.  For horizontal annotation text paths, CAP,
HALF, and BASE refer to the capline, halfline, and baseline of
the whole annotation text relative string.  For vertical
annotation text paths, CAP refers to the capline of the topmost
character, BASE refers to the baseline of the bottommost
character, and HALF refers to the vertical location midway
between the halflines of the topmost and bottommost characters.
#F 48
#D
#S 4.5.5/45/4 4.5.5/45/6 4.5.5/46/1 4.5.6/55/4
#T P03/6 P08/1 P08/2 P08/3 P08/4 P09/1 P09/2 P11/2
#C Only CHAR and STROKE precision imply exact realization of
annotation text relative alignment.  See the SRs on text
precision, above.  Recall that the TLC origin is the annotation
point in NPC.  Also, note the implication that for a given font
the relative placement of the baseline, halfline, and capline of
the same for all character bodies.

SR67.  The effect of NORMAL as the horizontal or vertical
component of annotation text alignment is equivalent to one of
the other defined values for annotation text alignment and
depends on annotation text path as follows:
annotation text path  |  (horizontal, vertical)
----------------------+------------------------
RIGHT                 |  (LEFT,       BASE)
LEFT                  |  (RIGHT,      BASE)
UP                    |  (CENTRE,     BASE)
DOWN                  |  (CENTRE,     TOP)
#F 48
#D
#S 4.5.5/46/3 4.5.5/47/1 4.5.6/55/4
#T P08/2 P08/4

***   Annotation text alignment: network traversal   ***

SR68.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current annotation text alignment of the PTSL is set to (NORMAL,
NORMAL).
#F
#D 2.13.6 2.13.7 3.4.6 3.4.7
#S 4.4.3/26/2 4.4.3/28/1 4.5.5/47/2 4.5.6/55/4 6.3/310/1
#T P11/2

SR69.  As part of the PTSL, the current annotation text alignment
is saved (but not changed) by execute structure and then, upon
completion of the sub-traversal of the invoked network, restored
to the saved value.
#F 113
#D 3.4.6 3.4.7
#S 4.4.3/28/1
#T P11/2

***   Annotation text character up vector: element creation   ***

SR70.  <Set annotation text character up vector> creates a "set
annotation text character up vector" element (in the open
structure), whose associated value is taken from the function's
parameter.
#F 46
#D 7.3.2.5.2
#S 4.4.1/23/1 4.5.2/38/3
#T P01/3 P01/4 P06/1

*** *** ***   Annotation text character up vector:   *** *** ***
*** *** ***   effect during traversal                *** *** ***

SR71.  Upon traversal of a "set annotation text character up
vector" element, the current annotation text character up vector
entry in the PHIGS traversal state list (PTSL) is set to the
element's associated value.
#F 46
#D 3.4.2 7.3.2.5.2
#S 4.5.2/38/3
#T P06/1 P09/1 P09/2 P11/3

SR72.  The annotation text character up vector aspect (specified
in TLC) causes the annotation text relative rectangle that has
been formed in the annotation text relative plane by application
of text font, annotation text character height, character
expansion factor, character spacing, annotation text path, and
annotation text alignment to be rotated within the text plane
about the TLC origin such that the up direction of the characters
is the same as that of the vector.
#F 46
#D
#S 4.5.5/45/2 4.5.5/45/5 4.5.6/55/4
#T P06/1 P09/1 P09/2 P11/3
#C Only STROKE precision implies exact realization of annotation
text character up vector.  See the SRs on text precision, above.

***  Annotation text character up vector: network traversal  ***

SR73.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current annotation text character up vector of the PTSL is set to
(0,1).
#F
#D 2.13.2 3.4.2
#S 4.4.3/26/2 4.4.3/28/1 4.5.5/47/2 4.5.6/55/4 6.3/309/1
#T P11/3

SR74.  As part of the PTSL, the current annotation text character
up vector is saved (but not changed) by execute structure and
then, upon completion of the sub-traversal of the invoked
network, restored to the saved value.
#F 113
#D 3.4.2
#S 4.4.3/28/1
#T P11/3

*** *** ***   Annotation style: element creation   *** *** ***

SR75.  <Set annotation style> creates a "set annotation style"
element (in the open structure), whose associated value is taken
from the function's parameter.
#F 49
#D 7.3.2.5.5
#S 4.4.1/23/1 4.5.2/38/3
#T P01/9 P01/10 P10/2 P10/3 P10/4 P10/5 P10/6

*** ***   Annotation style: effect during traversal   *** ***

SR76.  Upon traversal of a "set annotation style" element, the
current annotation style entry in the PHIGS traversal state list
(PTSL) is set to the element's associated value.
#F 49
#D 3.4.8 7.3.2.5.5
#S 4.5.2/38/3
#T P10/2 P10/3 P10/4 P10/5 P10/6 P11/4

SR77.  The list of available annotation styles returned by
<inquire annotation facilities> includes styles number 1 and 2
for all workstation types.
#F 268
#D 6.13.1.4 6.13.1.5
#S 4.14/113/3
#T P10/1

SR78.  When an annotation text relative is displayed, if its bound
annotation style is available on the workstation, then the
appearance of the annotation style agrees with the documented
specifications.
#F 49 268
#D 3.4.8 6.13.1.4 6.13.1.5
#S 4.5.6/55/5
#T P10/2 P10/3 P10/4 P10/5 P10/6

SR79.  When an annotation text relative is displayed, if its bound
annotation style is not available on the workstation, then
annotation style 1 (unconnected) is used to display the
annotation text relative.
#F 49 268
#D 3.4.8 6.13.1.4 6.13.1.5
#S 4.5.2/43/3
#T P10/3

SR80.  Annotation style #1 adds no visual effect to the
appearance of the annotation text relative primitive itself;
annotation style #2 causes a polyline to be drawn between the
annotation point and the reference point, using the current
polyline attributes.
#F 49 268
#D
#S 4.5.6/55/5
#T P10/2 P10/3 P10/4

SR81.  When available on the workstation to which posted,
annotation styles greater than 2 appear as specified in the ISO
register.
#F 49 268
#D 6.13.1.4 6.13.1.5
#S 4.1.2/15/2 4.5.6/55/5
#T P10/5

SR82.  When available on the workstation to which posted,
annotation styles less than 1 appear as specified in the
implementor documentation.
#F 49 268
#D 6.13.1.4 6.13.1.5
#S 4.1.1/15/1 4.5.6/55/5
#T P10/6 P10/7

*** ***   Annotation style: network traversal   *** ***

SR83.  At the start of the top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current annotation style of the PTSL is set to 1.
#F
#D 2.13.8 3.4.8
#S 4.4.3/26/2 4.4.3/28/1 6.3/310/1
#T P11/4

SR84.  As part of the PTSL, the current annotation style is saved
(but not changed) by execute structure and then, upon completion
of the sub-traversal of the invoked network, restored to the
saved value.
#F 113
#D 3.4.8
#S 4.4.3/28/1
#T P11/4

 
LOCAL DICTIONARY:
 
  Functions ---
   15: patr3   <annotation text relative 3>
   16: patr    <annotation text relative>
   36: pstxfn  <set text font>
   37: pstxpr  <set text precision>
   38: pschxp  <set character expansion factor>
   39: pschsp  <set character spacing>
   40: pstxci  <set text colour index>
   45: psatch  <set annotation text character height>
   46: psatcu  <set annotation text character up vector>
   47: psatp   <set annotation text path>
   48: psatal  <set annotation text alignment>
   49: psans   <set annotation style>
  113: pexst   <execute structure>
  266: pqtxf   <inquire text facilities>
  268: pqanf   <inquire annotation facilities>
  269: pqtxx   <inquire text extent>
  303: pqcets  <inquire current element type and size>
  304: pqceco  <inquire current element content>
 
  Data Structures ---
  2  ...  phigs_description_table
  2.2  ...  list_of_available_workstation_types
  2.7  ...  list_of_available_character_sets
  2.12 ...  default_text_attributes
  2.12.2  ...  default_text_font
  2.12.3  ...  default_text_precision
  2.12.4  ...  default_character_expansion_factor
  2.12.5  ...  default_character_spacing
  2.12.6  ...  default_text_colour_index
  2.13  ...  default_annotation_text_attributes
  2.13.1  ...  default_annotation_text_character_height
  2.13.2  ...  default_annotation_text_character_up_vector
  2.13.5  ...  default_annotation_text_path
  2.13.6  ...  default_annotation_text_alignment_horizontal
  2.13.7  ...  default_annotation_text_alignment_vertical
  2.13.8  ...  default_annotation_style
  3  ...  phigs_traversal_state_list
  3.3  ...  current_text_attributes
  3.3.2  ...  current_text_font
  3.3.3  ...  current_text_precision
  3.3.4  ...  current_character_expansion_factor
  3.3.5  ...  current_character_spacing
  3.3.6  ...  current_text_colour_index
  3.3.7  ...  current_text_font_asf
  3.3.8  ...  current_text_precision_asf
  3.3.9  ...  current_character_expansion_factor_asf
  3.3.10 ...  current_character_spacing_asf
  3.3.11 ...  current_text_colour_index_asf
  3.4  ...  current_annotation_text_attributes
  3.4.1  ...  current_annotation_text_character_height
  3.4.2  ...  current_annotation_text_character_up_vector
  3.4.5  ...  current_annotation_text_path
  3.4.6  ...  current_annotation_text_alignment_horizontal
  3.4.7  ...  current_annotation_text_alignment_vertical
  3.4.8  ...  current_annotation_style
  5  ...  workstation_state_list
  5.15  ...  colour_entry
  5.15.3  ...  colour_table
  5.15.3.1  ...  colour_index
  5.15.3.2  ...  colour_specification
  6  ...  workstation_description_table
  6.12  ...  text_entry
  6.12.1  ...  text_facilities
  6.12.1.1  ...  number_of_text_font_and_precision_pairs
  6.12.1.2  ...  list_of_text_font_and_precision_pairs
  6.12.1.6  ...  number_of_available_character_expansion_factors
  6.12.1.7  ...  minimum_character_expansion_factor
  6.12.1.8  ...  maximum_character_expansion_factor
  6.13  ...  annotation_entry
  6.13.1  ...  annotation_facilities
  6.13.1.1  ...  number_of_available_annotation_text_character_heights
  6.13.1.2  ...  minimum_annotation_text_character_height
  6.13.1.3  ...  maximum_annotation_text_character_height
  6.13.1.4  ...  number_of_available_annotation_styles
  6.13.1.5  ...  list_of_available_annotation_styles
  7  ...  structure_state_list
  7.3  ...  list_of_structure_elements
  7.3.1  ...  graphical_primitives
  7.3.1.7  ...  annotation_text_relative_3
  7.3.1.8  ...  annotation_text_relative
  7.3.2  ...  primitive_attributes
  7.3.2.4  ...  text_attributes
  7.3.2.4.1  ...  text_font
  7.3.2.4.2  ...  text_precision
  7.3.2.4.3  ...  character_expansion_factor
  7.3.2.4.4  ...  character_spacing
  7.3.2.4.5  ...  text_colour_index
  7.3.2.5  ...  annotation_text_attributes
  7.3.2.5.1  ...  annotation_text_character_height
  7.3.2.5.2  ...  annotation_text_character_up_vector
  7.3.2.5.3  ...  annotation_text_path
  7.3.2.5.4  ...  annotation_text_alignment
  7.3.2.5.5  ...  annotation_style
 
SEMANTIC CROSS-REFERENCES:
  04.01.04/SR07 04.01.04/SR08
 
LOCAL SUBROUTINES:

LOCATX draws an annotation text primitive at the real y-location
corresponding to the integer index given in YLOC.

LOCAT2 draws an annotation text string at the real y-location
corresponding to the integer index given in YLOC, and puts a
polymarker at the text position.

LOCANS draws an annotation text primitive with a distinct
annotation point and reference point, at the real y-location
corresponding to the integer index given in YLOC.

TSANUP draws an annotation text string with various values for
character up and for annotation text alignment.  The annotation
text strings are displayed along radii of a circle and are
enclosed by a text extent rectangle (except for one which is
deliberately drawn incorrectly).  TSANUP assumes that default
character height has been set to 1.0.

DSANST accepts a list of annotation styles and displays at most
eight (8) of them.


PROGRAM 1: Element creation and inquiring

CHARACTERISTICS: nnnn

OPERATOR SCRIPT: passive test.

DESIGN:

Use <inquire current element content> throughout to determine:
    celval = current element value as set by program
    recval = auxiliary element values implied by the standard's
             representation conventions.

Use <inquire current element type and size> throughout to determine:
    celsiz = current element size

*** ***   Annotation text character height   *** ***
<set annotation text character height>:
    character_height = 2.35

TEST: #SR 3 42
      "<Inquire current element type and size> should return
       annotation text character height as the type of the
       created element and the appropriate element size."

<inquire current element type and size> for current element type and
appropriate size
pass/fail depending on
  (current_element_type = annotation text character height and
   celsiz = values specified by the standard)

TEST: #SR 4 42
      "<Inquire current element content> should return the standard
       representation for the annotation text character height value."
<inquire current element content> for current element representation
pass/fail depending on
  (celval = 2.35 and
   recval = auxiliary values specified by the standard)

*** ***   Annotation text character up vector   *** ***
<set annotation text character up vector>:
    character_up_vector_x_component = -4.25
    character_up_vector_y_component = -5.13

TEST: #SR 3 70
      "<Inquire current element type and size> should return
       annotation text character up vector as the type of the
       created element and the appropriate element size."

<inquire current element type and size> for current element type
  and appropriate size
pass/fail depending on
  (current_element_type = annotation text character up vector and
   celsiz = values specified by the standard)

TEST: #SR 4 70
      "<Inquire current element content> should return the standard
       representation for the annotation text character up vector
       value."
<inquire current element content> for current element representation
pass/fail depending on
  (celval = (-4.25, -5.13) and
   recval = auxiliary values specified by the standard)

*** *** ***   Annotation text path   *** *** ***
<set annotation text path>:
    annotation text relative_path = LEFT

TEST: #SR 3 55
      "<Inquire current element type and size> should return
       annotation text path as the type of the created element and
       the appropriate element size."

<inquire current element type and size> for current element type and
appropriate size
pass/fail depending on
  (current_element_type = annotation text path and
   celsiz = values specified by the standard)

TEST: #SR 4 55 56
      "<Inquire current element content> should return the standard
       representation for all valid annotation text path values."

for txpath = RIGHT, LEFT, UP, and DOWN
   <set annotation text path> with annotation text relative_path = txpath
   <inquire current element content> for current element representation
   if (celval = txpath and
       recval = auxiliary values specified by the standard)
       OK so far
   else
      fail
      informative message on txpath
      goto donepath
   endif
next txpath

pass

donepath:

*** *** ***   Annotation text alignment   *** *** ***
<set annotation text alignment>:
    horizonal_annotation text relative_alignment = CENTRE
    vertical_annotation text relative_alignment  = BASE
TEST: #SR 3 63
      "<Inquire current element type and size> should return
       annotation text alignment as the type of the created
       element and the appropriate element size."

<inquire current element type and size> for current element type and
appropriate size
pass/fail depending on
  (current_element_type = annotation text alignment and
   celsiz = values specified by the standard)

TEST: #SR 4 63 64
      "<Inquire current element content> should return the standard
       representation for all valid annotation text alignment values."

for txhor = NORMAL, LEFT, CENTRE, and RIGHT
for txver = NORMAL, TOP, CAP, HALF, BASE, and BOTTOM

   <set annotation text alignment> with
      horizonal_annotation text relative_alignment = txhor
      vertical_annotation text relative_alignment  = txver
   <inquire current element content> for current element representation
   if (celval = (txhor, txver) and
       recval = auxiliary values specified by the standard)
       OK so far
   else
      fail
      informative message on (txhor, txver)
      goto donealign
   endif
next txver
next txhor

pass

donealign:

*** *** ***   Annotation style   *** *** ***
<set annotation style>:
    annotation style = -7

TEST: #SR 3 75
      "<Inquire current element type and size> should return
       annotation style as the type of the created element and
       the appropriate element size."

<inquire current element type and size> for current element type and
  appropriate size
pass/fail depending on
  (current_element_type = annotation style and
   celsiz = values specified by the standard)

TEST: #SR 4 75
      "<Inquire current element content> should return the standard
       representation for the annotation style value."
<inquire current element content> for current element representation
pass/fail depending on
  (celval = -7 and
   recval = auxiliary values specified by the standard)

END PROGRAM 1


PROGRAM 2: Appearance of text fonts 1 and 2

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

ASCII SPECIAL CHARACTERS: Each numbered character should be
recognizable from its name in the prompt.  Respond by entering a
list of numeric labels, in the same order as requested by the
prompt.  For instance if the screen shows:
   1: (
   2: *
   3: &
and the prompt asks for <asterisk>, <ampersand>, <opening
parenthesis>, the correct response is 2,3,1.  All 33 special
characters are checked for all three precisions in fonts 1 and 2,
so there will be several prompts for this heading.

ASCII UPPERCASE LETTERS: All 26 uppercase letters and one
lowercase letter should be displayed.  Identify the position of
the lowercase letter.  Character positions are displayed to the
left of each of the strings.  For example, in this line:
   9-16: DTSRFkCB
the lowercase "k" is in position 14.  As above, this test is
executed for all three precisions in fonts 1 and 2.

ASCII LOWERCASE LETTERS: All 26 lowercase letters and one
uppercase letter should be displayed.  Identify the position of
the uppercase letter.  Character positions are displayed to the
left of each of the strings.  As above, this test is executed for
all three precisions in fonts 1 and 2.

ASCII DIGITS: All 10 digits and one non-digit should be
displayed.  Identify the position of the non-digit.  Character
positions are displayed to the left of each of the strings.  As
above, this test is executed for all three precisions in fonts 1
and 2.

DISTINGUISHABILITY OF FONTS 1 AND 2: For each of the three
precisions, five lines are displayed, four in one font (1 or 2)
and one in the other font.  Identify the line in the distinctive
font.

FONT 1 MONOSPACED: Each line has a character string with some
leading potentially narrow characters and trailing potentially
wide characters.  In every string but one, each of its characters
should line up between the vertical lines.  Identify the one
string where this is not so.

DESIGN:

set up array for ASCII characters and names:
ascch = all special characters =  !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~

ascnm = names of all special characters
      = space, exclamation point, double quote, pound sign,
   dollar sign, percent sign, ampersand, apostrophe, left
   parenthesis, right parenthesis, asterisk, plus sign, comma, dash,
   period, slash, colon, semi-colon, less-than sign, equals,
   greater-than sign, question mark, at sign, left bracket, back
   slash, right bracket, carat, underline, single opening quote,
   left curly brace, vertical bar, right curly brace, tilde

TEST: #SR 5 6 7 14 18 19
      "Fonts 1 and 2 should both contain all the ASCII special
       characters, in any precision."

grpsiz = how many characters to display at a time = 6
for font = 1 to 2
for prec = STRING, CHAR, STROKE
    if (font,prec not directly available) goto end_fp_spec
    set text font to font
    set text precision to prec
    perm = array to randomize order of the 33 characters
    for ix = 0 to 32 by grpsiz
       display next grpsiz randomly ordered characters starting
          from ascch(perm(ix+1)), using annotation text
       OPQA/ASCII SPECIAL CHARACTERS: Identify, in order, the following
          characters: ascnm(perm(ix+1)) to ascnm(perm(ix+grpsiz))
       if (operator response incorrect) then
          fail
          goto end_ascii_special
       endif
    next ix
end_fp_spec:
next prec
next font

pass

end_ascii_special:

upper  = uppercase characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
noncap = a lowercase letter randomly chosen from "bdfhkt"
tststr = test string = noncap + upper

TEST: #SR 5 6 7 14 18 19
      "Fonts 1 and 2 should both contain all the ASCII uppercase
       letters, in any precision."

for font = 1 to 2
for prec = STRING, CHAR, STROKE
    if (font,prec not directly available) goto end_fp_upper
    set text font to font
    set text precision to prec
    perm = array to randomize order of the 27 characters
    display tststr in random order, using annotation text
    OPQA/ASCII UPPERCASE LETTERS: which character is NOT an
      uppercase letter?
    if (operator fails to identify noncap) then
       fail
       goto end_ascii_upper
    endif
end_fp_upper:
next prec
next font

pass

end_ascii_upper:

lower  = lowercase characters = 'abcdefghijklmnopqrstuvwxyz'
nonlow = an uppercase letter randomly chosen from upper
tststr = test string = nonlow + lower

TEST: #SR 5 6 7 14 18 19
      "Fonts 1 and 2 should both contain all the ASCII lowercase
       letters, in any precision."

for font = 1 to 2
for prec = STRING, CHAR, STROKE
    if (font,prec not directly available) goto end_fp_lower
    set text font to font
    set text precision to prec
    perm = array to randomize order of the 27 characters
    display tststr in random order, using annotation text
    OPQA/ASCII LOWERCASE LETTERS: which character is NOT a
      lowercase letter?
    if (operator fails to identify nonlow) then
       fail
       goto end_ascii_lower
    endif
end_fp_lower:
next prec
next font

pass

end_ascii_lower:

digit  = digit characters = '0123456789'
nondig = one non-digit randomly chosen from "CEISZ"
tststr = test string = nondig + digit

TEST: #SR 5 6 7 14 18 19
      "Fonts 1 and 2 should both contain all the ASCII digit
       characters, in any precision."

for font = 1 to 2
for prec = STRING, CHAR, STROKE
    if (font,prec not directly available) goto end_fp_digit
    set text font to font
    set text precision to prec
    perm = array to randomize order of the 11 characters
    display tststr in random order, using annotation text
    OPQA/ASCII DIGITS: which character is NOT a digit?
    if (operator fails to identify nondig) then
       fail
       goto end_ascii_digit
    endif
end_fp_digit:
next prec
next font

pass

end_ascii_digit:

TEST: #SR 5 6 8 14 18 19
      "Text fonts 1 and 2 should be visually distinguishable
       in any precision."

fonta = random integer, 1 or 2
fontb = 3 - fonta

for prec = STRING, CHAR, STROKE
    set text precision to prec
    perm = array to randomize order of 5 entries
    fonta = 3 - fonta
    fontb = 3 - fontb
    set text font to fonta
    for ix = 1 to 5
        if (ix = 5) set text font to fontb
        display "Test" at location perm(ix), using annotation text
    next ix
    OPQA/DISTINGUISHABILITY OF FONTS 1 AND 2: Which line has a
       different font?
    if operator response does not indicate location perm(5) then
       fail
       goto end_distin
    endif
next prec

pass

end_distin:

TEST: #SR 5 6 9 10 11 23 27 33 49 50
      "In text font 1, all character bodies affected by the same
       annotation text character height, character expansion factor, and
       character spacing should have the same width."

Use <inquire text extent> to determine
  ncwh = nominal character width/height ratio for font 1

numlin = number of lines to display = 6
ngline = incorrect line = random number from 1 to numlin

set text font = 1
set text precision = STROKE
set annotation text alignment = LEFT,HALF
set character spacing = chsp = 0.0

display labels for all numlin lines to be shown

chsp = 0.2
for ix = 1 to numlin
  chht   = random value from .2/numlin to .6/numlin
  chexp  = random value from .3 to 3
  chsiz  = horizontal distance per character
         = chht * (ncwh*chexp + chsp)
  numch  = number of characters this string = .6 / chsiz
  make sure numch between 4 and 25, else pick new values
  numnar = number of narrow characters = numch/2
  distrg = display string = numnar narrow characters
    followed by (numch-numnar) wide characters
  set annotation text character height = chht
  set character expansion = chexp
  display distrg at location ix, using annotation text
  if (ix = ngline) then
     offact = offset factor = .80 or 1.20
  else
     offact = offset factor = 1.00
  endif

  draw vertical lines between characters, assuming that chht,
    chsp, and chexp are in effect, distorted by offact
next ix

OPQA/FONT 1 MONOSPACED: In which line are the characters NOT
  located between the separators?
pass/fail depending on (operator indicates location ngline)

END PROGRAM 2


PROGRAM 3: Appearance of all text fonts

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

NON-MANDATORY REGISTERED TEXT FONTS: These screens display a
sample of supported registered text fonts (at most 8).  For each
displayed line, look up its text font identifier in the ISO
register and verify that the actual appearance of the annotation
text agrees with the ISO specification.

IMPLEMENTOR DEFINED TEXT FONTS: These screens display a sample of
implementor defined text fonts (at most 8).  For each displayed
line, look up its text font identifier in the implementor's
documentation and verify that the actual appearance of the
annotation text agrees with the specification.  Also verify that
font identifiers are described in a workstation independent way,
i.e. the same identifier must not specify different fonts for
different workstation types.

UNIFORM HEIGHT FOR CHARACTER BODIES: Each column has a character
string composed of some short characters followed by some tall
characters.  In every string but one, each of its characters
should line up between the horizontal lines.  Identify the one
string where this is not so.

ANNOTATION TEXT CHARACTER HEIGHT FOR SIZE OF CAPITAL LETTERS:
First, report all alphabetic stroke fonts to be tested, other
than 1 or 2.  The screen will then show several lines of boxed
annotation text relative primitives.  In all lines but one, the
capital letters should just fit between the displayed capline
(dashed) and baseline (dotted).  Identify the line in which the
letters are too tall or too short.

IDENTIFY UNREPRESENTED CHARACTER CODES: You must enter a list of
integers for which font 1 or 2 has no graphic representation.  If
this is an ASCII machine, values between 0 and 31 may qualify.
Any entries beyond the first 6 are ignored.  If all values are
representable, indicate the null list by entering "n". Since the
entered character codes will be used by the program to generate
an annotation text relative primitive, do not enter any codes
which will cause the implementation to take some special action.

APPEARANCE OF UNREPRESENTED CHARACTER CODES:  The implementation
must provide a special representation or symbol to indicate the
presence of character codes within an annotation text string for
which the font has no normal representation.  Identify all and
only the positions in the displayed annotation text string which
contain this distinctive symbol.  There may be different symbols
for different non-representable codes.

UNSUPPORTED TEXT FONT AND PRECISION PAIRS: All lines but one
should be identical, having defaulted or been explicitly set to
font=1, precision=STRING.  One line, written with font=2,
precision=STRING, should therefore be distinct and is the line to
be indicated.

DESIGN:

use <inquire text facilities> to determine
  lposfn = list of positive fonts and highest available precision
           for each, other than fonts 1 and 2
  lnegfn = list of non-positive fonts and highest available precision
           for each
  lstrk  = list of fonts available in STROKE precision

chstr = character string = AaZz09$;^}
lcc = list of character codes = codes for chstr

if (lposfn empty)
   informative message: no non-mandatory text fonts
   goto end_pos
endif

TEST: #SR 5 6 12 14
      "All positive text fonts should appear as specified in the
       ISO register."

informational message: SR 12 is indirectly confirmed in the
following test case since this test must be run against all
workstation types, and the ISO register documentation must be
correct for all of them.

ldisp = list of fonts to be displayed
if (number of entries in lposfn > 8) then
   ldisp = 8 randomly chosen from lposfn
else
   ldisp = all of lposfn
endif

display lcc

display chstr with annotation text for each font in ldisp, using
  that font's associated precision
label each chstr

OPQA/NON-MANDATORY REGISTERED TEXT FONTS: do all displayed,
  labelled text fonts agree with the corresponding description in
  the ISO register?
pass/fail depending on (operator responds "yes")

TEST: #SR 5 6 12 14 21
      "All positive text fonts should appear as specified in the
       ISO register, even when less precision is requested than
       is available for the font."

ldisp = list of fonts to be displayed
if (number of entries in lposfn > 8) then
   ldisp = 8 randomly chosen from lposfn
else
   ldisp = all of lposfn
endif

display lcc
display chstr with annotation text for each font in ldisp, using
  a precision less than that font's associated precision (or
  equal if STRING)
label each chstr

OPQA/NON-MANDATORY REGISTERED TEXT FONTS: do all displayed,
  labelled text fonts agree with the corresponding description in
  the ISO register?
pass/fail depending on (operator responds "yes")

end_pos:

if (lnegfn empty)
   informative message: no non-mandatory text fonts
   goto end_font_id
endif

TEST: #SR 5 6 12 14
      "All non-positive text fonts should be workstation independent
       and appear as specified in the implementor's documentation."

ldisp = list of fonts to be displayed
if (number of entries in lnegfn > 8) then
   ldisp = 8 randomly chosen from lnegfn
else
   ldisp = lnegfn
endif

display lcc
display chstr with annotation text for each font in ldisp, using
  that font's associated precision
label each chstr

OPQA/IMPLEMENTOR DEFINED TEXT FONTS: Answer y if both are true,
  otherwise n: 1) the implementor provides accurate documentation
  for all these fonts, and 2) the documentation indicates that a
  font identifier denotes the same font for all workstation types.
pass/fail depending on (operator responds "yes")

TEST: #SR 5 6 12 14 21
      "All non-positive text fonts should be workstation independent
       and appear as specified in the implementor's documentation,
       even when less precision is requested than is available
       for the font."

ldisp = list of fonts to be displayed
if (number of entries in lnegfn > 8) then
   ldisp = 8 randomly chosen from lnegfn
else
   ldisp = lnegfn
endif

display lcc
display chstr with annotation text for each font in ldisp, using
  a precision less than that font's associated precision (or
  equal if STRING)
label each chstr

OPQA/IMPLEMENTOR DEFINED TEXT FONTS: Answer y if both are true,
  otherwise n: 1) the implementor provides accurate documentation
  for all these fonts, and 2) the documentation indicates that a
  font identifier denotes the same font for all workstation types.
pass/fail depending on (operator responds "yes")

if (ldisp = all of lnegfn)
   all negative fonts displayed already
   goto end_font_id
endif

end_font_id:

TEST: #SR 5 6 9 10 23 27 33 49
      "In each text font, all character bodies affected by the
       same annotation text character height, character expansion
       factor, and character spacing should have the same height."

set text precision = STROKE
set character spacing = chsp = 0.4
set annotation text alignment = LEFT,TOP

numcol = number of columns to display = 6
ngcol  = incorrect column = random number from 1 to numcol

display labels for all numcol columns to be shown

for ix = 1 to numcol
  txfnt  = random value from lstrk
  Use <inquire text extent> to determine
    ncsh = nominal vertical character body size /
           requested annotation text character height
           for txfnt
  chht   = random value from .2/numcol to .6/numcol
  chexp  = random value from .3 to 3
  chsiz  = vertical distance per character
         = chht * (ncsh + chsp)
  numch  = number of characters this string = vert-space / chsiz
  make sure numch between 4 and 25, else pick new values

  numsht = number of short characters = numch/2
  distrg = display string = numsht short characters
    followed by (numch-numsht) tall characters
  set text font = txfnt
  set annotation text character height = chht
  set character expansion = chexp
  display distrg in column ix
  if (ix = ngcol) then
     offact = offset factor = .80 or 1.20
  else
     offact = offset factor = 1.00
  endif

  draw horizontal lines between characters, assuming that chht,
    chsp, and chexp are in effect, distorted by offact
next ix

OPQA/UNIFORM HEIGHT FOR CHARACTER BODIES: In which column are the
  characters NOT aligned between the separators?
pass/fail depending on (operator indicates location ngcol)

TEST: #SR 1 2 5 7 9 10 23 48 49 66
      "Annotation text character height magnitude should specify
       the nominal height, in TLC, from baseline to capline, of
       all capital letters within a font."

OPQA/ANNOTATION TEXT CHARACTER HEIGHT FOR SIZE OF CAPITAL
  LETTERS: Enter list of font identifiers available in stroke
  precision, other than 1 and 2, which support alphabetic
  characters.
alfont = list of alphabetic fonts from operator
alfont = alfont + 1,2

numlin = 6
ngline = random integer between 1 and numlin
for ix = 1,numlin
   str = 3 random capital letters
   chht = random value between (0.2 and 0.8) * line-increment
   compute correct location of base, cap lines
   if (ix = ngline) then
      draw incorrect base, cap lines
      if (chht < 0.5 * line-increment) then
         draw lines 25% too far apart
      else
         draw lines 25% too close
      endif
   else
      draw correct base, cap lines
   endif
   curfnt = random pick from alfont
   display str, using + or - chht and curfnt
   label str
next ix

OPQA/ANNOTATION TEXT CHARACTER HEIGHT FOR SIZE OF CAPITAL
  LETTERS: In which line are the upper-case letters NOT aligned
  between the dashed baseline and the dotted capline?
pass/fail depending on (operator picks location ngline)

OPQA/IDENTIFY UNREPRESENTED CHARACTER CODES: Enter list of 6 or
fewer character codes for which font 1 has no representation (n
if none).

unr1ls = operator response

OPQA/IDENTIFY UNREPRESENTED CHARACTER CODES: Enter list of 6 or
fewer character codes for which font 2 has no representation (n
if none).

unr2ls = operator response

if (unr1ls and unr2ls empty) then
   informative message: cannot test SR14, no unrepresentable
      character codes in fonts 1 or 2
   goto end_unrep
endif

TEST: #SR 6 7 13
      "There should be a implementation dependent way to depict a
       character code for which a font has no graphic
       representation."

if (unr1ls empty) then
   goto do_f2
endif

for all three precisions:
   str = random mix of ASCII and unrepresented character codes
   display str in font 1

   OPQA/APPEARANCE OF UNREPRESENTED CHARACTER CODES: The
   implementation should have a special symbol to indicate the
   presence of non-representable character codes within an
   annotation text string.  List, in order, all the character
   positions containing this special symbol.

   if (operator response incorrect) then
      fail
      goto end_unrep
   endif
next precision

if (unr2ls empty) then
   pass
   goto end_unrep
endif

do_f2:
for all three precisions:
   str = random mix of ASCII and unrepresented character codes
   display str in font 2

   OPQA/APPEARANCE OF UNREPRESENTED CHARACTER CODES: The
   implementation should have a special symbol to indicate the
   presence of non-representable character codes within an
   annotation text string.  List, in order, all the character
   positions containing this special symbol.

   if (operator response incorrect) then
      fail
      goto end_unrep
   endif
next precision
pass

end_unrep:

TEST: #SR 5 6 8 15 19
      "If annotation text relative primitive requests an
       unavailable font or precision, font=1 and precision=STRING
       should be used."

lunsfn,lunspr = list of unsupported font,precision pairs

within lposfn, find at most 2 fonts in non-STROKE precision.
for each such add entry to list: font and lowest unavailable
  precision.

within lnegfn, find at most 2 fonts in non-STROKE precision.
for each such add entry to list: font and lowest unavailable
  precision.

(minstr, maxstr) = (minimum, maximum) font identifier in lstrk
add to list of unsupported:
minstr -   1, STRING
minstr - 100, STROKE
maxstr +   1, STROKE
maxstr + 100, STRING

add (1,STRING) to lunsup
as last entry add (2,STRING) to lunsup
numlin = size of lunsup
perm = array to randomize order of lunsup

label all lines from 1 to numlin
do ix = 1 to numlin
   display annotation text using lunsfn(perm(ix)),
      lunspr(perm(ix)) on line ix
next ix

OPQA/UNSUPPORTED TEXT FONT AND PRECISION PAIRS: which line is
  different?
pass/fail depending on (operator picks annotation text written
  with (2,STRING))

END PROGRAM 3


PROGRAM 4: Character height and expansion factor

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

NEGATIVE CHARACTER HEIGHT AND EXPANSION FACTOR: All lines but one
should contain normal text - i.e. the characters should be
right-side up and not reversed left to right (mirror image).
Identify the line whose text is not normal.

DESIGN:

<inquire annotation facilities> to determine
naht = # available character heights
minht = minimum character height
maxht = maximum character height

TEST: #SR 43
      "Maximum character height should not be less than the
       minimum character height."
pass/fail depending on (maxht >= minht)

TEST: #SR 43 44
      "The minimum and maximum character heights should be
       positive."
pass/fail depending on (minht and maxht > 0)

TEST: #SR 43 45 47
      "The reported number of available character heights
       should be at least 0."
pass/fail depending on (naht >= 0)

TEST: #SR 9 20 21 22 27 28 29 46 47 49 50 51 52
      "Test cases for the visual effect of approximated
       annotation text attributes (character height and character
       expansion factor) in STRING and CHAR precision are not yet
       available."
pass

TEST: #SR 5 7 26 27 42 48 49
      "Only the magnitude of character expansion factor and
       character height should affect the annotation text
       primitive."

perm = permute 1 thru 5
chmag = magnitude of character height
cxmag = magnitude of character expansion factor
chstr = some non-symmetric characters = "2P4Q5R7"
label text lines
do ix = 1 to 5
   this = perm(ix)
   if (this < 3) then
      chht = -chmag
   else
      chht = +chmag
   endif

   if (mod(this,2) = 0) then
      chxp = -cxmag
   else
      chxp = +cxmag
   endif

   if (this = 5) then
      yup = -1 (reverse up and down)
   else
      yup = 1
   endif

   set character height    = chht
   set character expansion = chxp
   set character up        = 0,yup
   draw annotation text chstr on line #ix
next ix

OPQA/NEGATIVE CHARACTER HEIGHT AND EXPANSION FACTOR: Which line
  does NOT have normally oriented characters?
pass/fail depending on (operator indicates line with reversed text)

END PROGRAM 4


PROGRAM 5: Network inheritance and initialization for
           non-geometric annotation text attributes

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

STRUCTURE NETWORK INHERITANCE FOR TEXT FONT AND PRECISION: This
screen displays several left-right pairs of annotation text
relative primitives.  Make sure that all pairs except one have
matching text fonts and precisions.  Identify the non-matching
pair.

STRUCTURE NETWORK INHERITANCE FOR CHARACTER EXPANSION AND
SPACING: This screen displays several left-right pairs of
annotation text relative primitives.  Make sure that all pairs
except one have matching character expansion and spacing
attributes.  Identify the non-matching pair.

STRUCTURE NETWORK INHERITANCE FOR TEXT COLOUR INDEX: This screen
displays several left-right pairs of annotation text relative
primitives.  Make sure that all pairs except one have matching
colors.  Identify the non-matching pair.

DESIGN:

All test cases use same basic structure network for testing
inheritance.  Five (distinct if possible) values for the
attribute to be tested are set up and propagated throughout the
network.  The first value is the system default from the PDT.
Note that structure #104 is executed by both #103 and #101.
Actual results are displayed on the left, expected results
on the right, with the 14th deliberately made incorrect.

default = val#1
  |                  102
  |                 /  prim 2
  |               /    attr = val#3   val#3
  V        val#1/      exec 103---------------103
101           /        prim 8                   prim 3
  prim 1    /                                   attr = val#4
  exec 102/                                     prim 4
  prim 9                                        exec 104\
  attr = val#2                                  prim 7    \ val#4
  prim 10                                                   \
  transform             val#2                                 \
  exec 104-----------------------------------------------------104
  un-transform                                                   prim 5/11
  prim 13                                                        attr = val#5
  prim 14                                                        prim 6/12
  exec 105---------->105
                       expected values

*** *** *** ***   text font and precision   *** *** *** ***

ldisfn,ldispr = list of 5 distinct font,precision pairs
ldisfn(1),ldispr(1) = 1,STRING
ldisfn(2),ldispr(2) = 2,STROKE
ldisfn(3),ldispr(3) = 1,CHAR
ldisfn(4),ldispr(4) = 2,STRING

use <inquire text facilities> to find one other available font
if (another font found) then
   add it as 5th entry to ldisfn,ldispr
else
   add (1,STROKE) as 5th entry
endif

randomize location of annotation text primitives
set up CSS as described above
set all ASFs to INDIVIDUAL

display 14 pairs of annotation text primitives, using ldisfn and
  ldispr 1-5

TEST: #SR 5 6 14 16 17 19 20 24 25
      "The text font and precision attributes for the annotation
       text relative primitive should be saved and restored by
       <execute structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR TEXT FONT AND PRECISION:
  which pair of annotation text primitives does NOT match?
pass/fail depending on response = position of annotation text #14

*** *** ***   character expansion and spacing   *** *** ***

ldisxp,ldissp = list of 5 distinct expansion and spacing values
ldisxp(1),ldissp(1) = 1.0,  0.0
ldisxp(2),ldissp(2) = 0.4,  1.4
ldisxp(3),ldissp(3) = 0.7,  1.1
ldisxp(4),ldissp(4) = 1.3,  0.5
ldisxp(5),ldissp(5) = 1.7, -0.3

randomize location of annotation text primitives
set up CSS as described above
set all ASFs to INDIVIDUAL

display 14 pairs of annotation text primitives, using ldisxp and
  ldissp 1-5

TEST: #SR 5 26 27 30 31 32 33 35 36
      "The character expansion factor and character spacing
       attributes for the annotation text relative primitive
       should be saved and restored by <execute structure> during
       traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR CHARACTER EXPANSION AND
  SPACING: which pair of annotation text primitives does NOT match?
pass/fail depending on response = position of annotation text #14

*** *** *** ***   text colour index   *** *** *** ***

call DISCOL to try to get 5 distinct foreground colors,
  returning fcol = actual number of foreground colors

set up colind = list of distinguishable color indexes
if (fcol <= 1) then
   colind = selection from background and foreground colors
          = [1,0,1,1,0]
else
   colind = circular list of indices = [1,..,fcol, 1,..]
endif

randomize location of annotation text primitives
set up CSS as described above
set all ASFs to INDIVIDUAL

display 14 pairs of annotation text primitives, using colind 1-5

TEST: #SR 5 37 38 40 41
      "The annotation text color index attribute for the
       annotation text relative primitive should be saved and
       restored by <execute structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR TEXT COLOUR INDEX:
  which pair of annotation text relative primitives does NOT match?
pass/fail depending on response = position of annotation text #14

END PROGRAM 5


PROGRAM 6: Annotation text path, character height, expansion
           factor, spacing, and up vector

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

ANNOTATION TEXT PATH AND CHARACTER UP: A short text string should
be visible.  First, indicate whether the entire string is laid
out horizontally or vertically.  Next, indicate the up direction
of the individual characters.  Finally, type in the leftmost (for
a horizontal string) or topmost (for a vertical string)
character.

ANNOTATION TEXT CHARACTER HEIGHT, EXPANSION, AND SPACING FOR
HORIZONTAL PATHS: Several horizontal lines containing an
annotation text string are drawn with various values for the
character attributes.  The expected character body positions are
outlined with a dotted line and a dashed baseline, usually of a
different color than the annotation text itself.  Identify the
single line in which the characters do NOT fall within the dotted
boxes.  In the case of overlapping characters due to negative
character spacing, half-boxes are drawn, so that the boxes
themselves don't overlap.

ANNOTATION TEXT CHARACTER HEIGHT, EXPANSION, AND SPACING FOR
VERTICAL PATHS: Same as above, except that the annotation text
choices are vertical columns, not horizontal lines.  Note that
expected position is aligned on vertical centerline (not left- or
right-justified); the actual characters, therefore, must not
appear to the left or right of the expected box.  In the case of
overlapping characters due to negative character spacing,
half-boxes are drawn, so that the boxes themselves don't overlap.

DESIGN:

TEST: #SR 5 7 23 55 56 57 58 70 71 72
      "Annotation text path should specify the direction in which
       successive characters are generated and annotation text
       character up vector should rotate the resulting
       primitive."

set text font = 2
set text precision = STROKE
chstr = mostly non-symmetrical characters = "SPQR"
for txp = RIGHT,LEFT,UP,DOWN
   set annotation text path = txp
   rot = rotation amount = random 0,90,180,270 degrees
   set annotation text character up vector = rot
   draw chstr as an annotation text primitive

   OPQA/ANNOTATION TEXT PATH AND CHARACTER UP: Is text string as
      a whole oriented horizontally (1) or vertically (2)?
   opans = operator response
   if ((txp = LEFT or RIGHT) and (rot =  0 or 180)) or
      ((txp = UP   or DOWN)  and (rot = 90 or 270)) then
      truans = 1
   else
      truans = 2
   endif
   if (truans not= opans) then
      fail
      goto end_text_path
   endif

   OPQA/ANNOTATION TEXT PATH AND CHARACTER UP: Is the character
      up direction to the left (1), top (2), right (3), or bottom (4)?
   opans = operator response
   if (opans does not match rot) then
      fail
      goto end_text_path
   endif

   OPQA/ANNOTATION TEXT PATH AND CHARACTER UP: Identify the
      character to the left/top of the screen.
   if (operator response incorrect) then
      fail
      goto end_text_path
   endif

next txp
pass

end_text_path:

use <inquire text extent> with
  text font                  = 1
  character height           = 1 (WC)
  character spacing          = 0
  character expansion factor = 1
  text string                = "WWiig!"
to determine
  ncbht = nominal character body height
  ncbwd = nominal character body width

set annotation text path = RIGHT
set text font = 1
set text precision = STROKE
numlin = number of lines = 6
ngline = random number from 1 to numlin
for ix = 1 to numlin
   randomly select an annotation text character height, expansion
     factor, and spacing, to fit on one line

   calculate expected character boxes
   if (ix = ngline) then
      distort character boxes
   endif
   draw in character boxes, using dotted line style, color #2

   set non-unit scaling modelling transform to show that
     size of annotation-text is unaffected, even though
     location is affected.
   display annotation text "WWiig!" on line ix
   restore identity modelling transform
next ix

TEST: #SR 1 2 5 11 23 26 27 28 32 33 34 48 49 50 51 52 57 58 60
      "The size and shape of an annotation text string displayed
       with STROKE precision in a monospaced font on a horizontal
       annotation text path should conform exactly to the
       annotation text character height, expansion factor, and
       spacing in effect."

OPQA/ANNOTATION TEXT CHARACTER HEIGHT, EXPANSION, AND SPACING FOR
  HORIZONTAL PATHS: In which line are the characters of the
  annotation text string NOT aligned within dotted character
  boxes and on the dashed baseline?
pass/fail depending on (operator picks location ngline)

set annotation text path = DOWN
set text font = 1
set text precision = STROKE
numcol = number of columns = 6
ngcol  = random number from 1 to numcol
for ix = 1 to numcol
   randomly select an annotation text character height, expansion
     factor, and spacing, to fit on one column

   calculate expected character boxes
   if (ix = ngcol) then
      distort character boxes
   endif
   draw in character boxes, using dotted line style, color #2

   set non-unit scaling modelling transform to show that
     size of annotation-text is unaffected, even though
     location is affected.
   display annotation text "WWiig!" on line ix
   restore identity modelling transform
next ix

TEST: #SR 1 2 5 11 23 26 27 28 32 33 34 48 49 50 51 52 57 58 59
      "The size and shape of an annotation text string displayed
       with STROKE precision in a monospaced font on a vertical
       annotation text path should conform exactly to the
       annotation text character height, expansion factor, and
       spacing in effect."

OPQA/ANNOTATION TEXT CHARACTER HEIGHT, EXPANSION, AND SPACING FOR
  VERTICAL PATHS: In which column are the characters of the
  annotation text string NOT aligned within dotted character
  boxes and on the dashed centerline?
pass/fail depending on (operator picks location ngcol)

bestfn = a stroke text font other than 1, preferably not #2 and
         not monospaced

bestsc = best score so far for font properties = -1
bestfn = best font so far = -1
for ix = each available non-#1 stroke font
   thisfn = ixth font from <inquire text facilities>
   use <inquire text extent> with
     text font                  = thisfn
     character height           = 1
     character spacing          = 0
     character expansion factor = 1
     text string                = "WWW"
   to determine
     tcbhtw = nominal character body height for W
     tcbwdw = nominal character body width for W

   use <inquire text extent> with
     text font                  = thisfn
     character height           = 1
     character spacing          = 0
     character expansion factor = 1
     text string                = "iii"
   to determine
     tcbhti = nominal character body height for i
     tcbwdi = nominal character body width for i

   if (thisfn = 2) then
      fnscor = score for this font = 0
   else
      fnscor = score for this font = 1
   endif

   if (ncbwdi approx= ncbwdw) then
      do nothing
   else
      add 2 to fnscor
   endif

   if (fnscor > bestsc) then
      best font so far:
      bestsc = fnscor
      bestfn = thisfn
      ncbhtw = tcbhtw
      ncbwdw = tcbwdw
      ncbhti = tcbhti
      ncbwdi = tcbwdi
      if (fnscor >= 3) then
         got a non-2, non-monospaced font: goto got_font
      endif
   endif
next stroke font

if (bestsc <= -1) then
   message: skipping tests for proportionately spaced fonts; none
            available.
   goto endit
endif

got_font:

set annotation text path = LEFT
set text font = bestfn
set text precision = STROKE
numlin = number of lines = 6
ngline = random number from 1 to numlin
for ix = 1 to numlin
   randomly select an annotation text character height, expansion
      factor, and spacing, to fit on one line
   calculate expected character boxes
   if (ix = ngline) then
      distort character boxes
   endif
   draw in character boxes, using dotted line style, color #2
   display annotation text "WWiiiW" on line ix
next ix

TEST: #SR 1 2 5 11 23 26 27 28 32 33 34 48 49 50 51 52 57 58 60
      "The size and shape of an annotation text string displayed
       with STROKE precision in any font on a horizontal
       annotation text path should conform exactly to the
       annotation text character height, expansion factor, and
       spacing in effect."

OPQA/ANNOTATION TEXT CHARACTER HEIGHT, EXPANSION, AND SPACING FOR
  HORIZONTAL PATHS: In which line are the characters of the
  annotation text string NOT aligned within dotted character
  boxes and on the dashed baseline?
pass/fail depending on (operator picks location ngline)

set annotation text path = UP
set text precision = STROKE
numcol = number of columns = 6
ngcol  = random number from 1 to numcol
for ix = 1 to numcol
   randomly select an annotation text character height, expansion
     factor, and spacing, to fit in one column
   calculate expected character boxes
   if (ix = ngcol) then
      distort character boxes
   endif
   draw in character boxes, using dotted line style, color #2
   display annotation text "WWiiiW" in column ix
next ix

TEST: #SR 1 2 5 11 19 23 26 27 29 32 33 34 48 49 50 52 57 58 59
      "The size and shape of an annotation text string displayed
       with STROKE precision in any font on a vertical annotation
       text path should conform exactly to the annotation text
       character height, expansion factor, and spacing in
       effect."

OPQA/ANNOTATION TEXT CHARACTER HEIGHT, EXPANSION, AND SPACING FOR
  VERTICAL PATHS: In which column are the characters of the
  annotation text string NOT aligned within dotted character
  boxes and on the dashed centerline?
pass/fail depending on (operator picks location ngcol)

endit:

END PROGRAM 6


PROGRAM 7: Annotation text color index

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

DEFINED ANNOTATION TEXT COLOR INDICES: All annotation text lines
but one are drawn in the background color.  Identify the single
annotation text line drawn in the default foreground color.

UNDEFINED ANNOTATION TEXT COLOR INDICES: A star is drawn with
several horizontal annotation text lines beneath it.  Normally,
all of these will be the same color as the star.  Count up and
report the number of annotation text lines that match the star in
color.

DESIGN:

TEST: #SR 5 37 38
      "A defined annotation text color index should cause the
       addressed entry in the color table to be used when
       rendering an annotation text relative primitive."

bckcol = background color = realized color spec for entry #0
forcol = foreground color = realized color spec for entry #1

szcolt = maximum size of color table (including entry #0)
numlin = number of annotation text lines to be drawn = min(8, szcolt)
txcol  = random permutation of #0,#1, and numlin-2 random choices
         from entries #2 to #szcolt-1
visdx = from txcol, randomly select an entry to be made visible
        but not the one that contains 0, since this may not be
        re-settable.

for ix = 1 to numlin
   set entry txcol(ix) to bckcol
   randomly pick and set a precision, to ensure no interaction
   draw annotation text line #ix with text colour index = txcol(ix)
next ix

set entry txcol(visdx) to forcol

OPQA/DEFINED ANNOTATION TEXT COLOR INDICES: which annotation text
  line is visible?
pass/fail depending on (response = annotation text line colored
  by visdx)

end_def_col:

TEST: #SR 5 37 39
      "An undefined annotation text color index should cause entry
       number 1 in the color table to be used when rendering an
       annotation text relative primitive."

set entry #1 in color table opposite from BCKCOL
set entry #1 different from FORCOL - make sure that the undefined
  entries default to *current* color-rep of #1, not just a
  predefined color.

u1,u2,u3 = 3 undefined, positive color indices - all greater
  than maximum defined entry in color table
explct = number of explicit annotation text lines of color #1
       = random integer from 0 to 4

draw star with color #1

display interleaved:
  three annotation text lines of color u1,u2,u3,
  explct annotation text lines of color #1

OPQA/UNDEFINED ANNOTATION TEXT COLOR INDICES: how many annotation
  text lines are the same color as the star?
pass/fail depending on response = 3+explct

END PROGRAM 7


PROGRAM 8: Annotation text alignment

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

EXPLICIT ALIGNMENT FOR HORIZONTAL ANNOTATION TEXT: Each of the
dotted annotation text extent rectangles except one should
contain an annotation text primitive, aligned on a dashed
baseline, filling the rectangle from left to right. Identify the
single non-aligned annotation text primitive.

IMPLICIT ALIGNMENT FOR HORIZONTAL ANNOTATION TEXT: Same as for
EXPLICIT ALIGNMENT FOR HORIZONTAL ANNOTATION TEXT, above.

EXPLICIT ALIGNMENT FOR VERTICAL ANNOTATION TEXT: Same as for
EXPLICIT ALIGNMENT FOR HORIZONTAL ANNOTATION TEXT, above, except
that a dashed centerline is used to measure alignment.

IMPLICIT ALIGNMENT FOR VERTICAL ANNOTATION TEXT: Same as for
EXPLICIT ALIGNMENT FOR VERTICAL ANNOTATION TEXT, above.

DESIGN:

txstr = annotation text string to be used for test = "Widget!?"

use <inquire text extent> on horizontal txstr to determine:
  ntxwd  = nominal width of annotation text extent rectangle
  ntxht  = nominal height of annotation text extent rectangle

for each ix = vertical annotation text alignment
  use <inquire text extent> on horizontal txstr to determine:
      vtab(ix) = normalized height for this alignment
next ix

htab(left)   = normalized width of left line = 0
htab(center) = normalized width of center line = ntxwd/2
htab(right)  = normalized width of right line = ntxwd

Throughout, use text font = 2
                text precision = STROKE

table of alignments and paths to be tested:

     hor-align  vert-align  annotation text path
     algnh      algnv       algntp
     ---------  ----------  ---------
  1: left       top         left
  2: center     cap         right
  3: right      half        left
  4: right      base        right
  5: center     bottom      left
  6: left       bottom      right

set up PERM to randomize position

draw and label 6 identical horizontal annotation text rectangles,
  using dotted lines, distinct color, dashed baseline,
  stacked vertically, and labelled 1-6
for ix = 1,6
   set desired y-location based on perm(ix)
   calculate txpos = annotation text position, so as to fit annotation text
     into expected box, using values from algnh(ix),algnv(ix)
   if ix=6 then
      change txpos to generate incorrect result
   endif
   set annotation text alignment = algnh(ix), algnv(ix)
   set annotation text path = algntp(ix)
   draw annotation text at txpos
next ix

TEST: #SR 1 2 5 9 19 23 56 57 58 63 64 65 66
      "Explicit annotation text alignment attributes should
       affect the position of a horizontal annotation text
       rectangle in accordance with the values returned by
       <inquire text extent>."

OPQA/EXPLICIT ALIGNMENT FOR HORIZONTAL ANNOTATION TEXT: Which
  annotation text primitive is NOT aligned within the dotted
  annotation text extent rectangle on the dashed baseline?

pass/fail depending on
  (operator response indicates location of 6th annotation text primitive)

table of expected and requested alignments and paths to be tested:

                requested:             | expected:
     text path  hor-align  vert-align  | hor-align  vert-align
     algntp     ralgnh     ralgnv      | ealgnh     ealgnv
     ---------  ---------  ----------  | ---------  ----------
  1: left       normal     normal      | right      base
  2: right      normal     normal      | left       base
  3: left       center     normal      | center     base
  4: right      normal     top         | left       top
  5: left       normal     normal      | right      base

set up PERM to randomize position

draw and label 5 identical horizontal annotation text rectangles,
  using dotted lines, distinct color, dashed baseline,
  stacked vertically, and labelled 1-5
for ix = 1,5
   set desired y-location based on perm(ix)
   calculate txpos = annotation text position, so as to fit annotation text
     into expected box, using values from ealgnh(ix),ealgnv(ix)
   if ix=5 then
      change txpos to generate incorrect result
   endif
   set annotation text alignment = ralgnh(ix), ralgnv(ix)
   set annotation text path = algntp(ix)
   draw annotation text at txpos
next ix

TEST: #SR 1 2 5 9 19 23 57 58 63 64 65 66 67
      "Implicit annotation text alignment attributes should
       affect the position of a horizontal annotation text
       rectangle in accordance with the values returned by
       <inquire text extent>."

OPQA/IMPLICIT ALIGNMENT FOR HORIZONTAL ANNOTATION TEXT: Which
  annotation text primitive is NOT aligned within the dotted
  annotation text extent rectangle on the dashed baseline?

pass/fail depending on
  (operator response indicates location of 5th annotation text primitive)

use <inquire text extent> on vertical txstr to determine:
  ntxwd  = nominal width of annotation text extent rectangle
  ntxht  = nominal height of annotation text extent rectangle

for each ix = vertical annotation text alignment
  use <inquire text extent> on horizontal txstr to determine:
      vtab(ix) = normalized height for this alignment
next ix

htab(left)   = normalized width of left line = 0
htab(center) = normalized width of center line = ntxwd/2
htab(right)  = normalized width of right line = ntxwd

table of alignments and paths to be tested:

     hor-align  vert-align  annotation text path
     algnh      algnv       algntp
     ---------  ----------  ---------
  1: right      top         up
  2: left       cap         down
  3: center     half        up
  4: center     base        down
  5: left       bottom      up
  6: right      bottom      down

set up PERM to randomize position

draw and label 6 identical vertical annotation text rectangles,
  using dotted lines, distinct color, dashed centerline,
  placed adjacent left-to-right and labelled 1-6
for ix = 1,6
   set desired x-location based on perm(ix)
   calculate txpos = annotation text position, so as to fit
     annotation text into expected box, using values from
     algnh(ix),algnv(ix)
   if ix=6 then
      change txpos to generate incorrect result
   endif
   set annotation text alignment = algnh(ix), algnv(ix)
   set annotation text path = algntp(ix)
   draw annotation text at txpos
next ix

TEST: #SR 1 2 5 9 19 23 56 57 58 63 64 65 66
      "Explicit annotation text alignment attributes should
       affect the position of a vertical annotation text
       rectangle in accordance with the values returned by
       <inquire text extent>."

OPQA/EXPLICIT ALIGNMENT FOR VERTICAL ANNOTATION TEXT: Which
  annotation text primitive is NOT aligned within the dotted
  annotation text extent rectangle on the dashed centerline?

pass/fail depending on
  (operator response indicates location of 6th annotation text primitive)

table of expected and requested alignments and paths to be tested:

                requested:             | expected:
     text path  hor-align  vert-align  | hor-align  vert-align
     algntp     ralgnh     ralgnv      | ealgnh     ealgnv
     ---------  ---------  ----------  | ---------  ----------
  1: up         normal     normal      | center     base
  2: down       normal     normal      | center     top
  3: up         right      normal      | right      base
  4: down       normal     half        | center     half
  5: up         normal     normal      | center     base

set up PERM to randomize position

draw and label 5 identical vertical annotation text rectangles,
  using dotted lines, distinct color, dashed centerline,
  placed adjacent left-to-right and labelled 1-5
for ix = 1,5
   set desired x-location based on perm(ix)
   calculate txpos = annotation text position, so as to fit
     annotation text into expected box, using values from
     ealgnh(ix),ealgnv(ix)
   if ix=5 then
      change txpos to generate incorrect result
   endif
   set annotation text alignment = ralgnh(ix), ralgnv(ix)
   set annotation text path = algntp(ix)
   draw annotation text at txpos
next ix

TEST: #SR 1 2 5 9 19 23 57 58 63 64 65 66 67
      "Implicit annotation text alignment attributes should
       affect the position of a vertical annotation text
       rectangle in accordance with the values returned by
       <inquire text extent>."

OPQA/IMPLICIT ALIGNMENT FOR VERTICAL ANNOTATION TEXT: Which
  annotation text primitive is NOT aligned within the dotted
  annotation text extent rectangle on the dashed centerline?

pass/fail depending on
  (operator response indicates location of 5th annotation text primitive)

END PROGRAM 8


PROGRAM 9: Annotation text character up vector

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

ANNOTATION TEXT CHARACTER UP FOR HORIZONTAL ANNOTATION TEXT PATH:
The display should be a set of annotation text primitives
arranged as radii of a circle, all but one aligned in a dotted
annotation text extent rectangle with a dashed baseline.
Identify the single non-aligned annotation text primitive.

ANNOTATION TEXT CHARACTER UP FOR VERTICAL ANNOTATION TEXT PATH:
Same as for ANNOTATION TEXT CHARACTER UP FOR HORIZONTAL
ANNOTATION TEXT PATH, except the dashed line is a centerline, not
a baseline.

DESIGN:

throughout, use STROKE precision
use font#1 for horizontal path
txstr = "Going up?"

use <inquire text extent> on horizontal txstr to determine:
  ntxwd  = nominal width of annotation text extent rectangle
  ntxht  = nominal height of annotation text extent rectangle
  htab(ix) = normalized widths for horizontal alignments
  vtab(ix) = normalized heights for vertical alignments

numstr = number of strings to display = 7
ngstr = incorrect string identifier = random from 1-7
irad = inner radius of circle for display of annotation text strings
     = calculate from numstr and ntxht
orad = outer radius of circle for display of annotation text strings
     = calculate from irad and ntxwd
set up transform to fit annotation text circle on screen, centered at
  origin, with radius orad

annotation text alignments to be used:
   algnh    algnv
   ------   ------
1: center   base
2: left     cap
3: right    top
4: left     bottom
5: center   half
6: right    half
7: left     cap

set annotation text path = RIGHT
for ix = 1,numstr
   txang = angle for annotation text string = ix*2*pi / numstr
   draw and label as #ix a rectangle for expected position of
      annotation text string, based on txang, irad, orad
   txpos = requested annotation text position, based on txang,irad, and
      annotation text alignment to be requested.
   set annotation text alignment to (algnh(ix), algnv(ix))
   if (ix = ngstr) txang = txang +or- 0.125*2*pi/numstr
   chupx = cos(txang); chupy = sin(txang)
   set annotation text character up = chupx,chupy
   draw txstr at txpos
next ix

TEST: #SR 1 2 5 9 19 23 57 58 60 65 66 71 72
      "An annotation text primitive with STROKE precision and a
       horizontal annotation text path should be rotated
       according to the annotation text character up vector."

OPQA/ANNOTATION TEXT CHARACTER UP FOR HORIZONTAL ANNOTATION TEXT
  PATH: Which annotation text primitive is NOT aligned within the
  dotted annotation text extent rectangle on the dashed baseline?
pass/fail depending on (operator identifies annotation text #ngstr)

use font#2 for vertical path
txstr = "Up&@M"

use <inquire text extent> on horizontal txstr to determine:
  ntxwd  = nominal width of annotation text extent rectangle
  ntxht  = nominal height of annotation text extent rectangle
  htab(ix) = normalized widths for horizontal alignments
  vtab(ix) = normalized heights for vertical alignments

numstr = number of strings to display = 7
ngstr = incorrect string identifier = random from 1-7
irad = inner radius of circle for display of annotation text strings
     = calculate from numstr and ntxwd
orad = outer radius of circle for display of annotation text strings
     = calculate from irad and ntxht
set up transform to fit annotation text circle on screen, centered at
  origin, with radius orad

annotation text alignments to be used:
   algnh    algnv
   ------   ------
1: center   base
2: left     cap
3: right    top
4: left     bottom
5: center   half
6: right    half
7: left     cap

set annotation text path = DOWN
for ix = 1,numstr
   txang = angle for annotation text string = ix*2*pi / numstr
   draw and label as #ix a rectangle for expected position of
      annotation text string, based on txang, irad, orad
   txpos = requested annotation text position, based on
      txang,irad, and annotation text alignment to be requested.
   set annotation text alignment to (algnh(ix), algnv(ix))
   if (ix = ngstr) txang = txang +or- 0.125*2*pi/numstr
   chupx = cos(txang); chupy = sin(txang)
   set annotation text character up = chupx,chupy
   draw txstr at txpos
next ix

TEST: #SR 1 2 5 9 19 23 57 58 59 65 66 71 72
      "An annotation text primitive with STROKE precision and a
       vertical annotation text path should be rotated according
       to the annotation text character up vector."

OPQA/ANNOTATION TEXT CHARACTER UP FOR VERTICAL ANNOTATION TEXT
  PATH: Which annotation text primitive is NOT aligned within the
  dotted annotation text extent rectangle on the dashed
  centerline?
pass/fail depending on (operator identifies annotation text #ngstr)

END PROGRAM 9


PROGRAM 10: Annotation style

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

Throughout this program, when an annotation text primitive is
displayed, its reference point is marked with an asterisk
polymarker, and its annotation point with a circle polymarker.

ANNOTATION STYLE 1: This screen should display several examples
of annotation style #1 (reference point unconnected to annotation
point), and one example of a different style.  Identify the
distinct style.

UNSUPPORTED ANNOTATION STYLES: As above, for ANNOTATION STYLE 1.

ANNOTATION STYLE 2: This screen should display several examples
of annotation style #2 (reference point connected to annotation
point), and one example of a different style.  Identify the
distinct style.

NON-MANDATORY REGISTERED ANNOTATION STYLES: This screen displays
a sample of supported registered annotation styles (at most 8).
For each displayed style, look up its annotation style identifier
in the ISO register and verify that the actual appearance of the
style agrees with the ISO specification.

IMPLEMENTOR DEFINED ANNOTATION STYLES: This screen displays a
sample of implementor defined annotation styles (at most 8).  For
each displayed style, look up its annotation style identifier in
the implementor's documentation and verify that the actual
appearance of the style agrees with the specification.

COMPLETE DOCUMENTATION FOR IMPLEMENTOR ANNOTATION STYLES: No
associated picture.  Verify that all the entries in the list of
available annotation styles for this workstation type are
documented by the implementor.  The list may be a subset of the
documented annotation styles.

DESIGN:

use <inquire annotation facilities> to determine:
  numas  = number of available annotation styles
  lavsas = list of available standard annotation styles
  lavras = list of available registered (non-mandatory) annotation styles
  lavias = list of available implementor-defined annotation styles

TEST: #SR 77
      "The list of available annotation styles returned by
       <inquire annotation facilities> should include styles
       number 1 and 2."
pass/fail depending on (lavsas includes styles 1 and 2)

message to operator: throughout this program, annotation text
  reference point is marked with asterisk polymarker, annotation
  point with circle polymarker.

if (annotation style #1 not available) then
   message: skipping tests for style #1
   goto end_style_1
endif

*** *** ***   style #1 (unconnected)   *** *** ***

set up perm to randomize order
ngstyl = random integer from 1 to 3
display interspersed 3 actual and 3 simulated examples of style #1,
  with actual #ngstyl done incorrectly (use style #2)

TEST: #SR 1 2 5 75 76 78 80
      "The mandatory annotation style number 1 should leave the
       reference point and the annotation point of the annotation
       text primitive unconnected."

OPQA/ANNOTATION STYLE 1: Which annotation style is different?
pass/fail depending on (operator correctly identifies primitive
  with style #2)

if (2 not available) then
   goto end_style_1
endif

lunsup = list of (mostly) unsupported annotation styles, contains:
  a negative unsupported type (< minimum in lavias)
  a positive unsupported type (> maximum in lavras)
  1,
  2, if supported (the only non-#1 style)
  0, if not in lavias

Display in random order annotation styles from lunsup

TEST: #SR 5 75 76 78 79 80
      "Unavailable annotation styles should be displayed as
       annotation style number 1."

OPQA/UNSUPPORTED ANNOTATION STYLES: Which annotation style is
  different?
pass/fail depending on (the #2 annotation style selected)

end_style_1:

*** *** ***   style #2 (connected)   *** *** ***

if (annotation style #2 not available) then
   message: skipping tests for style #2
   goto end_style_2
endif

set up perm to randomize order
ngstyl = random integer from 1 to 3
display interspersed 3 actual and 3 simulated examples of style #2,
  with actual #ngstyl done incorrectly (use style #1)

TEST: #SR 1 2 5 75 76 78 80
      "The mandatory annotation style number 2 should connect
       the reference point and annotation point with a polyline,
       using the current attributes."

OPQA/ANNOTATION STYLE 2: Which annotation style is different?
pass/fail depending on (operator correctly identifies primitive
  with style #2)

end_style_2:

*** *** ***   registered styles   *** *** ***

regdx = size of lavras
if regdx < 1 skip to neg_type, with message

if regdx < 9
   stydis = styles to be displayed = all annotation styles in lavras
else
   stydis = styles to be displayed = 8 annotation styles randomly
                                     selected from lavras
endif

display in order and label all annotation styles in stydis

TEST: #SR 5 75 76 78 81
      "The registered non-mandatory annotation styles (> 2) should
       agree with their registered description."

OPQA/NON-MANDATORY REGISTERED ANNOTATION STYLES: Is each
  annotation style depicted according to its numeric identifier's
  specification in the ISO register?
pass/fail depending on (operator responds "yes")

neg_type:

*** *** ***   implementor-defined styles   *** *** ***

impdx = size of lavias
if impdx < 1 goto end_annotation_style, with message

if impdx< 9
   stydis = styles to be displayed = all annotation styles in lavias
else
   stydis = styles to be displayed = 8 annotation styles randomly
                                     selected from lavias
endif

display in order and label all annotation styles in stydis

TEST: #SR 5 75 76 78 82
      "Implementor-defined annotation styles (< 1) should agree
       with the descriptions supplied by the implementor."

OPQA/IMPLEMENTOR DEFINED ANNOTATION STYLES: Is each annotation
  style depicted according to its numeric identifier's
  specification in the implementor documentation?
pass/fail depending on (operator responds "yes")

if (impdx <= 8) then
   all implementor annotation styles already shown - skip test
   goto end_annotation_style
endif

TEST: #SR 82
      "All reported implementor-defined annotation styles
       available for a given workstation type should be
       documented by the implementor."

OPQA/COMPLETE DOCUMENTATION FOR IMPLEMENTOR ANNOTATION STYLES:
  Are all these reportedly available annotation styles documented
  by the implementor <lavias> ?
pass/fail depending on (operator responds "yes")

end_annotation_style:

END PROGRAM 10


PROGRAM 11: Network inheritance and initialization for geometric
            annotation text attributes

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

STRUCTURE NETWORK INHERITANCE FOR ANNOTATION TEXT CHARACTER
HEIGHT: This screen displays several left-right pairs of
annotation text strings, of varying annotation text character
height.  Make sure that all pairs except one have matching
heights.  Identify the non-matching pair.

STRUCTURE NETWORK INHERITANCE FOR ANNOTATION TEXT ALIGNMENT: This
screen displays several left-right pairs of annotation text
strings, each aligned differently with respect to the annotation
point, which is represented by an asterisk polymarker.  Make sure
that all pairs except one have matching alignments.  Identify the
non-matching pair.

STRUCTURE NETWORK INHERITANCE FOR ANNOTATION TEXT PATH AND
ANNOTATION TEXT CHARACTER UP: This screen displays several
left-right pairs of annotation text strings, with various
annotation text paths and annotation text character up vectors.
Make sure that all pairs except one match with respect to both
these attributes. Identify the non-matching pair.

STRUCTURE NETWORK INHERITANCE FOR ANNOTATION STYLE: This screen
displays several left-right pairs of annotation text strings,
with various annotation styles. Make sure that all pairs except
one have matching annotation styles.  Identify the non-matching
pair.

DESIGN:

All test cases use the same basic structure network for testing
inheritance.  Five (distinct if possible) values for the
attribute(s) to be tested are set up and propagated throughout
the network.  The first value is the system default from the PDT.
Note that structure #104 is executed by both #103 and #101.
Actual results are displayed on the left, expected results on the
right, with the 14th deliberately made incorrect.

default = val#1
  |                  102
  |                 /  prim 2
  |               /    attr = val#3   val#3
  V        val#1/      exec 103---------------103
101           /        prim 8                   prim 3
  prim 1    /                                   attr = val#4
  exec 102/                                     prim 4
  prim 9                                        exec 104\
  attr = val#2                                  prim 7    \ val#4
  prim 10                                                   \
  transform             val#2                                 \
  exec 104-----------------------------------------------------104
  un-transform                                                   prim 5/11
  prim 13                                                        attr = val#5
  prim 14                                                        prim 6/12
  exec 105---------->105
                       expected values


*** *** *** ***   annotation text character height   *** *** *** ***

lhts = list of 5 distinct annotation text character heights
     = [.010, .020, .015, .025, .030]
  with 0.010 (default) in 1st position.

randomize location of annotation text strings
set up CSS as described above; throughout, scale such that char-ht
  of 0.01 and nearby values are reasonably visible.
display 14 pairs of annotation text strings with annotation text
  character heights from lhts

TEST: #SR 5 48 53 54
      "The annotation text character height attribute should be
       saved and restored by <execute structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR ANNOTATION TEXT CHARACTER
  HEIGHT: Which pair of annotation text strings does NOT match?
pass/fail depending on (location of 14th primitive selected)


*** *** *** ***   annotation text alignment   *** *** *** ***

lalgnh, lalgnv = list of 5 distinct annotation text alignments
                 (default in first position) =

        horizontal  vertical
        ----------  --------
   1:   LEFT        BASE
   2:   CENTER      HALF
   3:   RIGHT       CAP
   4:   LEFT        BOTTOM
   5:   RIGHT       TOP

randomize location of annotation text strings
set up CSS as described above
display 14 pairs of annotation text strings with annotation text
  alignments from lalgnh, lalgnv;
show alignment point for each with polymarker

TEST: #SR 5 65 66 68 69
      "The annotation text alignment attribute should be saved and
       restored by <execute structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR ANNOTATION TEXT ALIGNMENT: Which
  pair of annotation text strings is NOT similarly aligned with respect
  to the marked annotation point?
pass/fail depending on (location of 14th primitive selected)


*** ***   annotation text path and character up   *** ***

ltxp, lchup = list of 5 distinct annotation text paths and character-ups
              (default in first position) =

        annotation text path   annotation text character up
        ---------   ------------
   1:   RIGHT        0, 1
   2:   UP          -3, 1
   3:   LEFT         1,-3
   4:   DOWN        -3,-1
   5:   LEFT        -1,-3

randomize location of annotation text strings
set up CSS as described above
display 14 pairs of annotation text strings with annotation text
  paths and character ups from ltxp, lchup

TEST: #SR 5 57 58 61 62 71 72 73 74
      "The annotation text path and annotation text character up
       attributes should be saved and restored by <execute
       structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR ANNOTATION TEXT PATH AND
  CHARACTER UP: Which pair of annotation text strings does NOT match?
pass/fail depending on (location of 14th primitive selected)


*** *** ***   annotation style   *** *** ***

Use <inquire annotation facilities> to develop
  lanst = list of available annotation styles
lanst contains exactly five elements
element #1 = 1 (default)
element #2 not= element#4

if (less than 2 styles available) then
   message: skip test
   goto end_style
endif

randomize location of annotation text strings
set up CSS as described above
display 14 pairs of annotation text strings with annotation
  styles from lanst

TEST: #SR 5 76 83 84
      "The annotation style attribute should be saved and
       restored by <execute structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR ANNOTATION STYLE: Which
  pair of annotation text strings does NOT match?
pass/fail depending on (location of 14th primitive selected)

end_style:

END PROGRAM 11

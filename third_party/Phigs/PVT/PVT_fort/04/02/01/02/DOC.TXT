TITLE: Polyline - workstation support

MODULE#: 04.02.01.02

DESCRIPTION:  This module tests the bundled entries and other
workstation facilities for polyline. These entries control the
appearance of polylines when they are under bundled (as opposed
to individual) control.

SEMANTIC REQUIREMENTS:

*** *** *** ***   Polyline index inquiry   *** *** *** ***

SR1.  If current element is polyline index then <inquire current
element type and size> returns the element type as polyline index
and the appropriate element size.
#F 303
#D 7.3.2.1.1
#S 4.4.4/29/5
#T P01/1

SR2.  If current element is polyline index then <inquire current
element content> returns the appropriate data for polyline index.
#F 304
#D 7.3.2.1.1
#S 4.4.4/29/5
#T P01/2

*** *** ***   Polyline index traversal binding   *** *** ***

SR3.  Upon traversal of a "polyline" or "polyline 3" element, the
current polyline index in the PTSL is bound to the resulting
primitive.
#F 25
#D 3.1.1 7.3.1.1 7.3.1.2
#S 4.5.2/38/3 4.5.2/40/3
#T P09/1 P09/2 P09/3 P10/1 P10/2 P11/1 P11/2 P11/3 P11/4 P11/5 P11/6
   P11/7 P11/8 P11/9 P12/1

*** *** ***   Polyline index: element creation   *** *** ***

SR4.  <Set polyline index> creates a "set polyline index"
element, (in the open structure), whose associated value is taken
from the function's parameter.
#F 25
#D 7.3.2.1.1
#S 4.4.1/23/1 4.5.2/38/3
#T P01/1 P01/2 P10/1 P10/2 P11/1 P11/2 P11/3 P11/4 P11/5 P11/6 P11/7
   P11/8 P11/9

*** ***   Polyline index: effect during traversal   *** ***

SR5.  Upon traversal of a "set polyline index" element, the
current polyline index entry in the PHIGS traversal state list
(PTSL) is set to the element's associated value.
#F 25
#D 3.1.1 7.3.2.1.1
#S 4.4.1/23/1 4.5.2/38/3
#T P10/1 P10/2 P11/1 P11/2 P11/3 P11/4 P11/5 P11/6 P11/7 P11/8 P11/9
   P12/1

SR6.  When a polyline is displayed, if its bound polyline index is
defined on the workstation, then the indicated bundle is the
source for the bundled aspects of that polyline.
#F 25
#D 3.1.1 5.9.1 5.9.2
#S 4.5.2/38/7 4.5.2/39/7 4.5.3/43/4
#T P09/1 P09/2 P09/3 P10/1 P11/1 P11/2 P11/3 P11/4 P11/5 P11/6 P11/7
   P11/8 P11/9 P12/1

SR7.  When a polyline is displayed, if its bound polyline index is
undefined on the workstation, then bundle number 1 in the
polyline bundle table is the source for the bundled aspects of
that polyline.
#F 25
#D 3.1.1 5.9.1 5.9.2
#S 4.5.2/38/7 4.5.2/39/7 4.5.2/43/3 4.5.3/43/4
#T P10/2

*** *** ***   Polyline index: network traversal   *** *** ***

SR8.  At the start of a top-level traversal of a structure
network (not a sub-traversal caused by execute structure), the
current polyline index of the PTSL is set to 1.
#F
#D 2.10.1 3.1.1
#S 4.4.3/26/2 4.4.3/28/1 6.3/309/1
#T P12/1

SR9.  As part of the PTSL, the current polyline index is saved
(but not changed) by execute structure and then, upon completion
of the sub-traversal of the invoked network, restored to the
saved value.
#F 113
#D 3.1.1
#S 4.4.3/28/1
#T P12/1

*** *** ***   Polyline Representation   *** *** ***

SR10.  <Set polyline representation> causes an entry to be
defined.
#F 63
#D 5.9.1 5.9.2.1
#S 4.5.2/42/3 4.5.2/43/2
#T P02/2 P02/3 P02/6 P02/7 P02/9 P02/10

SR11.  <Set polyline representation> sets the polyline bundle's
linetype, linewidth scale factor, and colour index.
#F 63
#D 5.9.2
#S 4.5.2/43/2 4.5.2/42/3
#T P01/3 P02/4 P02/8 P02/11 P07/5 P07/6 P07/7 P07/8 P07/9 P07/10

SR12.  <Inquire list of polyline indices> returns the list of all
defined polyline indices.
#F 222
#D 5.9.1 5.9.2.1
#S n
#T P02/1 P02/2 P02/3 P02/5 P02/6 P02/7 P02/9 P02/10 P02/12

SR13.  <Inquire polyline representation> works for all defined
entries.
#F 222 223
#D 5.9.1 5.9.2.1
#S n
#T P02/12

SR14.  <Inquire polyline representation> returns the polyline
bundle's linetype, linewidth scale factor, and colour index as
set, when type of returned values specified as SET.
#F 223
#D 5.9.2
#S 4.11/108/1
#T P01/3 P02/4 P02/8 P02/11

SR15.  <Inquire polyline representation> returns the polyline
bundle's linetype, linewidth scale factor, and colour index as
realized, when type of returned values specified as REALIZED.
#F 223
#D 5.9.2
#S 4.11/108/1
#T P02/5 P04/5 P06/5 P07/5 P07/6 P07/7 P07/8 P07/9 P07/10 P08/1 P08/3

SR16.  <Inquire polyline representation> returns representation
for bundle number 1, if type of returned values is REALIZED, and
bundle index is undefined.
#F 222 223
#D 5.9.2
#S n
#T P02/5

*** *** ***   Maximum size of bundle table   *** *** ***

SR17.  <Inquire workstation state table lengths> returns the
maximum size of polyline bundle table.
#F 285
#D 6.21.1
#S n
#T P03/1 P03/2

SR18.  There must be at least 20 settable entries available in
the polyline bundle table.
#F 63 285
#D 5.9 6.21.1
#S 4.14/114/2 6.7/324/1
#T P03/1

*** *** ***   Predefined bundle facilities   *** *** ***

SR19.  <Inquire polyline facilities> returns the number of
predefined polyline bundle entries.
#F 262
#D 6.10.1.7
#S n
#T P04/1 P04/6

SR20.  <Inquire predefined polyline representation> returns the
linetype, linewidth scale factor, and polyline colour index for a
predefined polyline bundle.
#F 263
#D 6.10.2
#S n
#T P04/1 P04/2 P04/3 P04/4 P04/7 P05/2 P09/1 P09/2 P09/3

SR21.  Every workstation must have at least 5 predefined polyline
bundles.
#F 262 263
#D 6.10.1.7 6.10.2
#S 4.14/113/3 4.14/114/2 6.7/321/1
#T P04/6

SR22.  No two of the first 5 predefined polyline bundles have
identical sets of attributes.
#F 263
#D 6.10.2
#S 4.5.2/42/3 4.14/113/3 4.14/114/2 6.7/321/1
#T P04/7

SR23.  The n predefined polyline bundles in the Workstation
Description Table (WDT) are indexed as 1-n.
#F 263
#D 6.10.2
#S 6.7/321/1
#T P04/1 P05/2
#C The standard presumes this because in section 6.7 the predefined
bundles in the WDT do not mention index as a data item, nor is there a
way to get a list of these indices (<inquire polyline facilities> gives
the number of predefined bundles, but not a list thereof).

SR24.  Immediately after <open workstation>, for each WDT
predefined polyline entry there exists a Workstation State List
(WSL) polyline entry with the same attributes, including the same
polyline index.
#F 222 223 263 3
#D 5.9.2 6.10.2
#S 4.5.2/42/3 6.6/317/1 6.7/321/1
#T P05/1 P05/2 P09/1 P09/2

SR25.  Immediately after <open workstation>, the polyline bundle
table contains nothing but the entries initialized from the WDT
predefined polyline bundle table.
#F 222 223 262 3
#D 5.9.2 6.10.2
#S 4.5.2/42/3 6.6/317/1 6.7/321/1
#T P05/1

*** *** ***   Validity of predefined bundles   *** *** ***

SR26.  Each predefined polyline bundle has a linetype within the
list of available linetypes.
#F 262 263
#D 6.10.1.2 6.10.2.1
#S 5.12.1/232/2
#T P04/2 P04/5

SR27.  Each predefined polyline bundle has a linewidth scale
factor which generates a linewidth within the minimum and maximum
linewidths.
#F 262 263
#D 6.10.1.4 6.10.1.5 6.10.1.6 6.10.2.2
#S 5.12.1/232/2
#T P04/3 P04/5

SR28.  Each predefined polyline bundle has a colour index within
range of the predefined colour indices.
#F 263 277
#D 6.10.2.3 6.17.2.4
#S 6.7/321/1
#T P04/4 P04/5

*** *** ***   linetype support   *** *** ***

SR29.  The absolute value of the number of available linetypes
returned from <inquire polyline facilities> indicates the length
of the list of available linetypes.
#F 262
#D 6.10.1.1 6.10.1.2
#S 6.7/321/1
#T P06/1

SR30.  The list of available linetypes contains all registered
types, and includes 1-4.
#F 262
#D 6.10.1.2
#S 4.5.3/43/5 4.14/113/3 4.14/114/2 6.7/321/1
#T P06/2

SR31.  If the number of available linetypes is positive, the list
of available linetypes contains any implementation-dependent
types.
#F 262
#D 6.10.1.1 6.10.1.2
#S n
#T P06/3

SR32.  If the number of available linetypes is negative, the list
of available linetypes does not contain any implementation
dependent types.
#F 262
#D 6.10.1.1 6.10.1.2
#S n
#T P06/4

SR33.  All the linetypes in the list of available linetypes are
valid and realizable for the workstation.
#F 63 262
#D 5.9.2.2 6.10.1.1 6.10.1.2
#S n
#T P06/5

SR34.  Positive linetypes are standard or registered;
non-positive linetypes are implementation-dependent.
#F 63 262
#D 5.9.2.2 6.10.1.2
#S 4.5.3/43/5
#T P06/3 P06/4

SR35.  When a polyline is displayed, if its linetype ASF is bundled,
then its linetype aspect is taken from the polyline bundle
determined by the polyline index.
#F 25 62 63
#D 3.1.1 3.1.5 5.9.2.1 5.9.2.2
#S 4.5.2/39/7 4.5.3/43/4
#T P11/1 P11/2 P11/3

SR36.  When available on the workstation to which posted,
linetypes 1 through 4 appear as solid, dashed, dotted, and
dashed-dotted lines, respectively.
#F
#D 6.10.1.1 6.10.1.2
#S 4.5.3/43/5
#T P11/1

SR37.  When available on the workstation to which posted,
linetypes greater than 4 appear as specified in the ISO register.
#F
#D 6.10.1.1 6.10.1.2
#S 4.1.2/15/2 4.5.3/43/5
#T P11/2

SR38.  When available on the workstation to which posted,
linetypes less than 1 appear as specified in the implementor
documentation.
#F
#D 6.10.1.1 6.10.1.2
#S 4.1.1/15/1 4.5.3/43/5
#T P11/3

*** *** ***   linewidth scale factor support   *** *** ***

SR39.  <Inquire polyline facilities> describes the realizable
linewidths for a workstation type, via the number of available
linewidths, nominal linewidth, minimum linewidth, and maximum
linewidth.
#F 262
#D 6.10.1.3 6.10.1.4 6.10.1.5 6.10.1.6
#S n
#T P07/1 P07/5 P07/6 P07/7 P07/8 P07/9 P07/10

SR40.  The nominal linewidth, minimum linewidth, and maximum
linewidth are all positive.
#F 262
#D 6.10.1.4 6.10.1.5 6.10.1.6
#S 6.7/321/1
#T P07/2

SR41.  Workstations must support at least one linewidth.
#F 63 262
#D 5.9.2.3 6.10.1.3 6.10.1.4 6.10.1.5 6.10.1.6
#S 4.14/114/2 6.7/321/1
#T P07/3

SR42.  Any linewidth scale factor, whether or not resulting in a
valid linewidth for that workstation, may be specified for a
polyline bundle when invoking <set polyline representation>.
#F 63
#D 5.9.2.3
#S n
#T P07/4 P11/4 P11/5 P11/6 P11/7

SR43.  When a polyline is displayed, if its linewidth scale factor
ASF is bundled, then its logical linewidth is equal to the
linewidth scale factor determined by the polyline index times the
workstation's nominal linewidth.
#F 25 62 63
#D 3.1.1 3.1.6 5.9.2.1 5.9.2.3
#S 4.5.2/39/7 4.5.3/43/4
#T P11/4 P11/5 P11/6 P11/7

SR44.  When a polyline is displayed, if its logical linewidth is
available on the workstation, then the actual linewidth agrees
with the logical linewidth.
#F 25 62 63
#D 5.9.2.1 5.9.2.3 6.10.1.3 6.10.1.4 6.10.1.5 6.10.1.6
#S 4.5.2/39/7 4.5.3/43/4 4.5.3/43/6
#T P11/4

SR45.  When a polyline is displayed, if its logical linewidth is
not available on the workstation, then the actual linewidth is
the nearest available to the logical linewidth.
#F 25 62 63
#D 5.9.2.1 5.9.2.3 6.10.1.3 6.10.1.4 6.10.1.5 6.10.1.6
#S 4.5.2/39/7 4.5.3/43/4 4.5.3/43/6
#T P11/5 P11/6 P11/7


*** *** ***   polyline colour index support   *** *** ***

SR46.  Any non-negative polyline colour index, whether or not
defined for that workstation, may be specified for a polyline
bundle when invoking <set polyline representation>.
#F 63
#D 5.9.2.4
#S n
#T P08/2 P11/8 P11/9

SR47.  When a polyline is displayed, if its polyline colour index
ASF is bundled, then its polyline colour index is taken from the
polyline bundle determined by the polyline index.
#F 25 62 63
#D 3.1.1 3.1.7 5.9.2.1 5.9.2.4
#S 4.5.2/39/7 4.5.3/43/4
#T P08/1 P08/3 P11/8 P11/9

SR48.  When a polyline is displayed, if its polyline colour index is
available on the workstation, then the polyline colour index is
realized as itself.
#F 223 235
#D 5.9.2.1 5.9.2.4 5.15.3
#S 4.5.2/39/7 4.5.2/43/3 4.5.3/43/4 4.5.12/63/4
#T P08/1 P11/8

SR49.  When a polyline is displayed, if its polyline colour index is
undefined, then the polyline colour index is realized as colour
index 1.
#F 223 235
#D 5.9.2.1 5.9.2.4 5.15.3
#S 4.5.2/39/7 4.5.2/43/3 4.5.3/43/4 4.5.12/63/4
#T P08/3 P11/9

 
LOCAL DICTIONARY:
 
  Functions ---
    3: popwk   <open workstation>
   25: pspli   <set polyline index>
   62: psiasf  <set individual asf>
   63: psplr   <set polyline representation>
  113: pexst   <execute structure>
  222: pqepli  <inquire list of polyline indices>
  223: pqplr   <inquire polyline representation>
  235: pqeci   <inquire list of colour indices>
  262: pqplf   <inquire polyline facilities>
  263: pqpplr  <inquire predefined polyline representation>
  277: pqcf    <inquire colour facilities>
  285: pqwksl  <inquire workstation state table lengths>
  303: pqcets  <inquire current element type and size>
  304: pqceco  <inquire current element content>
 
  Data Structures ---
  2  ...  phigs_description_table
  2.10 ...  default_polyline_attributes
  2.10.1  ...  default_polyline_index
  3  ...  phigs_traversal_state_list
  3.1  ...  current_polyline_attributes
  3.1.1  ...  current_polyline_index
  3.1.5  ...  current_linetype_asf
  3.1.6  ...  current_linewidth_scale_factor_asf
  3.1.7  ...  current_polyline_colour_index_asf
  5  ...  workstation_state_list
  5.9  ...  polyline_entry
  5.9.1  ...  number_of_polyline_bundle_table_entries
  5.9.2  ...  polyline_bundle_table
  5.9.2.1  ...  polyline_index
  5.9.2.2  ...  linetype
  5.9.2.3  ...  linewidth_scale_factor
  5.9.2.4  ...  polyline_colour_index
  5.15  ...  colour_entry
  5.15.3  ...  colour_table
  6  ...  workstation_description_table
  6.10 ...  polyline_entry
  6.10.1  ...  polyline_facilities
  6.10.1.1  ...  number_of_available_linetypes
  6.10.1.2  ...  list_of_available_linetypes
  6.10.1.3  ...  number_of_available_linewidths
  6.10.1.4  ...  nominal_linewidth
  6.10.1.5  ...  minimum_linewidth
  6.10.1.6  ...  maximum_linewidth
  6.10.1.7  ...  number_of_predefined_polyline_indices
  6.10.2  ...  predefined_polyline_bundle_table
  6.10.2.1  ...  linetype
  6.10.2.2  ...  linewidth_scale_factor
  6.10.2.3  ...  polyline_colour_index
  6.17  ...  colour_entry
  6.17.2  ...  colour_facilities
  6.17.2.4  ...  number_of_predefined_colour_indices
  6.21  ...  maximum_table_lengths
  6.21.1  ...  maximum_number_of_polyline_bundle_table_entries
  7  ...  structure_state_list
  7.3  ...  list_of_structure_elements
  7.3.1  ...  graphical_primitives
  7.3.1.1  ...  polyline_3
  7.3.1.2  ...  polyline
  7.3.2  ...  primitive_attributes
  7.3.2.1  ...  bundle_index_attributes
  7.3.2.1.1  ...  polyline_index
 
LOCAL SUBROUTINES:

DISPLB selects a specified number of predefined bundles at random
from the polyline bundle table which are distinct in all their
attributes. If there are not enough completely distinct bundles,
DISPLB tries to maximize the number of different attributes.

DRWPLB draws a set of actual polylines using the specified bundle
values, and a set of expected polylines, using the attribute
values returned by <inquire predefined polyline representation>.
It draws the expected polyline incorrectly at a specified
position.

SHPLBW tests the rendering of a given linewidth, and returns the
pass/fail result.


PROGRAM 1: Simple setting and inquiring

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

Use <inquire current element content> throughout to determine:
    celval = current element value as set by program
    recval = auxiliary element values implied by the standard's
             representation conventions.

Use <inquire current element type and size> throughout to determine:
    celsiz = current element size

*** *** *** *** ***   Polyline index   *** *** *** *** ***
<set polyline index>:
    polyline_index = 8

TEST: #SR 1 4
      "<Inquire current element type and size> should return
       polyline index as the type of the created element and the
       appropriate element size."
<inquire current element type and size> for current element type
pass/fail depending on
  (current_element_type = polyline_index
   celsiz               = value specified by the standard)

TEST: #SR 2 4
      "<Inquire current element content> should return the
       standard representation for the polyline index value."
<inquire current element content> for current element representation
pass/fail depending on
  (celval = 8 and
   recval = auxiliary values specified by the standard)

*** *** *** ***  polyline representation set and inquire *** ***

<set polyline representation>:
  index     = 2
  linetype  = 3
  linewidth scale factor
            = 4.0
  colour    = 5
<inquire polyline representation> for index #2, as set

TEST: #SR 11 14
      "Polyline attributes should be returned as set."
pass/fail depending on
   (linetype               = 3   and
    linewidth scale factor = 4.0 and
    colour                 = 5)

END PROGRAM 1


PROGRAM 2: Setting entries of various kinds

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

<inquire workstation state table lengths> to determine maximum
   number of entries:
   mne = maximum number of entries

*** *** *** *** ***    initialized entries   *** *** *** *** ***

<inquire list of polyline indices> to determine initialized entries
   nie = number of initialized entries
   aii = an initialized index
TEST: #SR 12
      "<Inquire list of polyline indices> should return
       initialized indices."
if (<inquire list of polyline indices> indicates error) then
   fail
   goto undefined_test
else
   pass
endif

initialized_test:

<inquire polyline representation> for index# aii, as set
   establishes:
      old_linetype
      old_linewidth_scale_factor
      old_colour
if old_linetype < 4 then
   new_linetype  = old_linetype  + 1
else
   new_linetype  = 3
endif
new_linewidth_scale_factor
            = old_linewidth_scale_factor * 1.5
new_colour  = old_colour    + 1

<set polyline representation> sets:
  index      = aii
  linetype   = new_linetype
  linewidth_scale_factor
             = new_linewidth_scale_factor
  colour     = new_colour

<inquire list of polyline indices> returns defined list

TEST: #SR 10 12
      "Re-defining a system-initialized entry should not change
       the number of defined entries."
pass/fail depending on (current number of entries = nie)

TEST: #SR 10 12
      "Initialized bundle entry should be reported as defined
       after being set."
if (defined list includes #aii) then
   pass
else
   fail
   goto undefined_test
endif

<inquire polyline representation> for index# aii, as set
TEST: #SR 11 14
      "New values should be set for initialized bundle entry."
pass/fail depending on
   (linetype               = new_linetype               and
    linewidth_scale_factor = new_linewidth_scale_factor and
    colour                 = new_colour)

*** *** *** *** ***    undefined entries   *** *** *** *** ***

undefined_test:

<inquire list of polyline indices> returns defined list
determine lowest undefined index (not in defined list) = lui
determine current number defined entries = cnde

TEST: #SR 12 15 16
      "<Inquire polyline representation> should return attributes
       for bundle #1 when inquiring an undefined entry as
       REALIZED."
<inquire polyline representation> as REALIZED for index #lui
   to get undefined_bundle.
<inquire polyline representation> as REALIZED for index #1
   to get bundle #1.
pass/fail depending on (undefined_bundle = bundle #1).

If (number of initialized entries
   >= max size of bundle table) then
   skip rest of undefined_test; goto redefined_test
endif

If (number of initialized entries
   >= max table size in test program) then
   skip rest of undefined_test; goto redefined_test
endif

<set polyline representation>:
   index     = lui
   linetype  = 3
   linewidth_scale_factor
             = 4.0
   colour    = 5

<inquire list of polyline indices> to determine
   listot = total number of entries in list

TEST: #SR 10 12
      "Defining an undefined entry should increment the number of
       defined entries."
pass/fail depending on (listot = cnde + 1)

TEST: #SR 10 12
      "Undefined bundle entry should be reported as defined after
       set."
if (resulting list of indices contains lui) then
   pass
else
   fail
   goto redefined_test
endif

<inquire polyline representation> for index #lui, as set
TEST: #SR 11 14
      "New values should be set for undefined bundle entry."
pass/fail depending on
   (linetype               = 3    and
    linewidth_scale_factor = 4.0  and
    colour                 = 5)

*** *** *** *** ***    redefined entries   *** *** *** *** ***

redefined_test:

dpi  = defined polyline index
cnde = current number of defined entries

<set polyline representation>:
   index     = dpi
   linetype  = 2
   linewidth_scale_factor
             = 3.0
   colour    = 4

new_linetype  = 3
new_linewidth_scale_factor
              = 4.0
new_colour    = 5

<set polyline representation>:
   index = dpi
   linetype  = new_linetype
   linewidth_scale_factor
             = new_linewidth_scale_factor
   colour    = new_colour

<inquire list of polyline indices> to determine
   nnde = new number of defined entries

TEST: #SR 10 12
      "Re-defining a user-defined entry should not change number
       of defined entries."
pass/fail depending on (nnde = cnde)

TEST: #SR 10 12
      "Redefined bundle entry should be reported as defined after
       set."
if (resulting list of indices contains dpi) then
   pass
else
   fail
   goto end_redefined_test
endif

<inquire polyline representation> for index #dpi, as set
TEST: #SR 11 14
      "New values should be set for redefined bundle entry."
pass/fail depending on
   (linetype               = new_linetype  and
    linewidth_scale_factor = new_linewidth_scale_factor and
    colour                 = new_colour)

end_redefined_test:

*** *** *** *** ***    access all defined entries   *** *** *** *** ***

TEST: #SR 12 13
      "<Inquire list of polyline indices> and <inquire polyline
       representation> should detect all defined entries."
Use <inquire list of polyline indices> to get
    list of defined indices
if (non-zero error code) then
   fail
   goto end_access_all
endif
For each defined index, apply <inquire polyline representation>
   if (non-zero error code) then
      fail
      goto end_access_all
   endif
loop to next index
pass

end_access_all:

END PROGRAM 2


PROGRAM 3: Polyline bundle table length

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

<inquire workstation state table lengths> to determine
   mpbe = maximum polyline bundle entries

TEST: #SR 17 18
      "<Inquire workstation state table lengths> should report at
       least 20 entries as maximum size of polyline bundle table."
pass/fail depending on (mpbe >= 20)

Use <inquire list of polyline indices> to determine
   nde = number of defined entries and
   mpli = maximum defined polyline index
nemp = number of empty entries = mpbe - nde
TEST: #SR 17
      "The program should be able to define additional polyline
       bundle entries, up to the maximum."
do pli = mpli+1, mpli+nemp
   set polyline bundle entry, with index = pli
   if error signalled then
      fail
      goto done
   endif
loop

pass

done:

END PROGRAM 3


PROGRAM 4: Validity of predefined polyline bundles

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

mpci = maximum predefined color index

Use <inquire polyline facilities> to determine
   npe = number of predefined entries
   nalt = number of available linetypes
   nomlw = nominal linewidth
   minlw = minimum linewidth
   maxlw = maximum linewidth

linerr = false = linetype error found yet
lwerr  = false = linewidth error found yet
colerr = false = color error found yet
rlzerr = false = realized error found yet

TEST: #SR 19 20 23
      "<Inquire predefined polyline representation> should be
       able to access as many entries as reported by <inquire
       polyline facilities>."
do pli = 1 to npe
   <inquire predefined polyline representation> for pli to determine
      linty = linetype
      plwsf = predefined linewidth scale factor
      plci  = polyline color index
   if error then
      fail
      goto nxt_test
   endif

   if linty is not in the list of available linetypes then
      linerr = true
      erpllt = erroneous linty
   endif

   genlw = plwsf * nomlw = generated linewidth
   if genlw < minlw or > maxlw then
      lwerr = true
      erlw  = erroneous plwsf
   endif

   if plci < 0 or > mpci then
      colerr = true
      erplci = erroneous plci
   endif

   set polyline representation #3 to linty, plwsf, plci
   inquire polyline representation #3, as realized
   if (reported aspects not= linty, plwsf, plci) then
      rlzerr = true
      erbun  = pli
   endif

next pli
pass

TEST: #SR 20 26
      "All linetypes in predefined polyline bundles should
       themselves be in the list of available linetypes."
if linerr then
   fail
   message about erpllt
else
   pass
endif

TEST: #SR 20 27
      "All linewidth scale factors in predefined polyline bundles
       should generate linewidths within the minimum and maximum
       linewidths."
if lwerr then
   fail
   message about erlw
else
   pass
endif

TEST: #SR 20 28
      "All color indices in predefined polyline bundles should
       themselves be in the predefined color table."
if colerr then
   fail
   message about erplci
else
   pass
endif

TEST: #SR 15 26 27 28
      "All aspects of all predefined polyline bundles should be
       reported as realizable by <inquire polyline representation>."
if rlzerr then
   fail
   message about erbun
else
   pass
endif

nxt_text:

TEST: #SR 19 21
      "<Inquire polyline facilities> should report at least 5
       predefined entries."
if npe < 5 then
   fail
   goto done
else
   pass
endif

TEST: #SR 20 22
      "The first five predefined polyline bundle entries should
       all be mutually distinguishable."
do pli = 1 to 5
  <inquire predefined polyline representation> for index pli, determine
    pdlt = predefined linetype
    pdlw = predefined linewidth scale factor
    pdci = predefined polyline color index
  do pli2 = 1 to pli-1
     if svpdlt (pli2) = pdlt  and
        svpdlw (pli2) = pdlw  and
        svpdci (pli2) = pdci    then
          fail
          message about pli, pli2
          goto done_dist
     endif
  loop
  svpdlt (pli) = pdlt
  svpdlw (pli) = pdlw
  svpdci (pli) = pdci
loop
pass

done_dist:

END PROGRAM 4

PROGRAM 5: WSL polyline bundles initialized properly

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

msgsuf = message suffix = "opening workstation."

check_table:

<open workstation>

<inquire polyline facilities> to determine
   npe = number of predefined polyline entries in WDT

<inquire list of polyline indices> to determine
   spbt = size of WSL polyline bundle table
TEST: #SR 24 25
      "WSL polyline bundle table should be the same size as the
       predefined polyline bundle table after " + msgsuf
if spbt not= npe then
   fail
   message about spbt and npe
else
   pass
endif

TEST: #SR 20 23 24
      "Each WSL polyline entry should have the same attributes as
       the corresponding predefined polyline entry after " + msgsuf
do pli = 1 to min(npe,spbt)
  <inquire predefined polyline representation> for index pli, determine
    pdlt = predefined linetype
    pdlw = predefined linewidth scale factor
    pdci = predefined polyline color index
  <inquire polyline representation> for index pli, determine
    dlt = defined linetype
    dlw = defined linewidth scale factor
    dci = defined polyline color index
  if dlt = pdlt and
     dlw = pdlw and
     dci = pdci    then
       OK so far
  else
     fail
     message about pli
     goto end_check
  endif
loop
pass

end_check:
alter bundle table - insert new or different entry
<close workstation>
if (msgsuf = "opening workstation.") then
   msgsuf = "re-opening workstation."
   goto check_table
endif

END PROGRAM 5

PROGRAM 6: Linetype facilities

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

<inquire polyline facilities> to determine
   nalt = number of available linetypes
errcod = false
stdlt(1 thru 4) = false
impdep = false
do ltid = 1 to abs(nalt)
   <inquire polyline facilities> to determine
      thislt = nth linetype
   keep track of non-zero error indicators:
   if errind not= 0 then
      errcod = true
      message about errind and ltid
      goto loop
   endif
   lt(ltid) = thislt
   keep track of linetypes 1-4:
   if thislt >= 1 and <= 4 then
      stdlt(thislt) = true
   endif
   keep track of implementation-dependent types (non-positives):
   if thislt < 1 then
      impdep = true
   endif
loop

TEST: #SR 29
      "All entries within the reported size of the list of
       available linetypes should be accessible."
pass/fail depending on (NOT errcod)

TEST: #SR 30
      "The list of available linetypes should contain 1 thru 4."
pass/fail depending on (stdlt(1) and stdlt(2) and stdlt(3) and stdlt(4))

if nalt > 0 then (positive number of available linetypes)
   if impdep then
      no test
   else
      TEST: #SR 31 34
            "When system reports that no implementation-dependent
             linetypes are available, none should be."
      do implt = 0 to -3
         <set polyline representation>, index #1, linetype = implt
         if not rejected as invalid then
            fail
            message about implt
            goto endimp
         endif
      loop
      pass
      endimp:
   endif
else (nalt <= 0)
   TEST: #SR 32 34
         "Negative number of available linetypes should indicate
          that list contains no implementation-dependent
          linetypes."
   pass/fail depending on (NOT impdep)
endif

TEST: #SR 15 33
      "All entries within the reported list of available
       linetypes should be realizable and valid."
do ltid = 1 to abs(nalt)
  thislt = lt(ltid)
  <set polyline representation>, index #3, linetype = thislt
  if rejected as invalid then
     fail
     message about thislt
     goto done
  endif
  <inquire polyline representation>, index #3, as realized to determine
     rlt = realized linetype
  if rlt not= thislt then
     fail
     message about thislt and rlt
     goto done
  endif
loop
pass

done:

END PROGRAM 6

PROGRAM 7: Linewidth facilities

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

<inquire polyline facilities> to determine:
   nalw  = number of available linewidths
   nomlw = nominal linewidth
   minlw = minimum linewidth
   maxlw = maximum linewidth

Informative message about: nalw, nomlw, minlw, maxlw

TEST: #SR 39
      "Maximum linewidth should not be less than minimum."
pass/fail depending on (maxlw >= minlw)

TEST: #SR 40
      "The nominal linewidth, minimum linewidth, and maximum
       linewidth should all be positive."
pass/fail depending on (minlw and maxlw and nomlw > 0)

TEST: #SR 41
      "The reported number of available linewidths should be at
       least 0."
pass/fail depending on (nalw >= 0)

minsc = minlw/nomlw = minimum scale factor
maxsc = maxlw/nomlw = maximum scale factor

TEST: #SR 42
      "All linewidth scale factors should be accepted as valid."
<set polyline representation>, index #4, scale_factor = minsc/10
if error signalled then
   goto errval
endif
<set polyline representation>, index #4, scale_factor = maxsc*10
if error signalled then
   goto errval
endif
<set polyline representation>, index #4, scale_factor = -10.0
if error signalled then
   goto errval
endif
pass
valok = true
goto done_valid

errval:
fail
valok = false
message about scale_factor and error code

done_valid:

TEST: #SR 11 15 39
      "The reported minimum linewidth should be realizable."
<set polyline representation>, index #4, scale_factor = minsc
<inquire polyline representation>, index #4 as realized,
  to determine rlw = realized linewidth scale factor
pass/fail depending on (rlw app= minsc)

TEST: #SR 11 15 39
      "The reported maximum linewidth should be realizable."
<set polyline representation>, index #4, scale_factor = maxsc
<inquire polyline representation>, index #4 as realized,
  to determine rlw = realized linewidth scale factor
pass/fail depending on (rlw app= maxsc)

if (not valok) then
   informative message: skipping coercion tests
   goto skip_coerce
endif

TEST: #SR 11 15 39
      "A linewidth scale factor set as less than the minimum
       should be realized as the reported minimum."
<set polyline representation>, index #4, scale_factor = minsc/3
<inquire polyline representation>, index #4 as realized,
  to determine rlw = realized linewidth scale factor
pass/fail depending on (rlw app= minsc)

TEST: #SR 11 15 39
      "A linewidth scale factor set as greater than the maximum
       should be realized as the reported maximum."
<set polyline representation>, index #4, scale_factor = maxsc*3
<inquire polyline representation>, index #4 as realized,
  to determine rlw = realized linewidth scale factor
pass/fail depending on (rlw app= maxsc)

TEST: #SR 11 15 39
      "A linewidth scale factor set as less than zero
       should be realized as the reported minimum."
<set polyline representation>, index #4, scale_factor = -abs(maxsc)
<inquire polyline representation>, index #4 as realized,
  to determine rlw = realized linewidth scale factor
pass/fail depending on (rlw app= minsc)

skip_coerce:

if (nalw not= 0) goto done

TEST: #SR 11 15 39
      "If the reported number of available linewidths is zero,
       then all linewidths between the reported minimum and
       maximum should be realizable."

incr = (maxsc/minsc) ^ 0.25
thisc = minsc
for ix = 1 to 3
   thisc = thisc * incr
   <set polyline representation>, index #4, scale_factor = thisc
   <inquire polyline representation>, index #4 as realized,
      to determine rlw = realized linewidth scale factor
   if (rlw app= thisc) then
      OK so far
   else
      fail
      goto done
   endif
next ix
pass

done:

END PROGRAM 7


PROGRAM 8: Polyline color index

CHARACTERISTICS: ynnn

OPERATOR SCRIPT: passive test.

DESIGN:

loop thru color table to determine:
  mci = maximum defined color index
undci = mci + 1 = undefined color index

<set polyline representation>, index #5, polyline color index = mci

TEST: #SR 15 47 48
      "<Inquire polyline representation> should report a defined
       polyline colour index realized as itself."
<inquire polyline representation>, index #5 to determine
   rplci = realized polyline color index
if rplci = mci then
   pass
else
   fail
   message about rplci
endif

TEST: #SR 46
      "Any non-negative color index should be accepted as valid."
<set polyline representation>, index #5, polyline color index = undci
if error signalled then
   fail
   message about undci
else
   pass
endif

TEST: #SR 15 47 49
      "<Inquire polyline representation> should report an
       undefined polyline colour index realized as 1."
<inquire polyline representation>, index #5 to determine
   rplci = realized polyline color index
if rplci = 1 then
   pass
else
   fail
   message about rplci
endif

END PROGRAM 8


PROGRAM 9: Appearance of predefined polyline bundles

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

WORKSTATION DESCRIPTION AND STATE LIST TABLES, INDICES 1-5: This
screen displays 6 pairs (consisting of the first 5, with one
repeated) of predefined polyline bundles and individual
polylines.  Identify the pair of polylines that is different.

WORKSTATION DESCRIPTION AND STATE LIST TABLES, INDICES > 5: This
screen displays several pairs (at most 8) of predefined polyline
bundles and individual polylines.  Identify the pair of polylines
that is different.

PREDEFINED POLYLINE BUNDLES: This screen displays a sample (at
most 8) of predefined polyline bundles and their bundle values
for linetype, linewidth scale factor, and color index, as
reported by <inquire predefined polyline representation>.  For
each displayed bundle, verify that 1) the actual appearance of
the polyline agrees with the aspect values reported on the screen
and 2) these both agree with any external documentation provided
by the implementor.

DESIGN:

set all ASFs to BUNDLED

use <inquire polyline facilities> to determine:
  nprei  = number of predefined bundles

*** *** ***   predefined polyline bundles 1-5

numbun = 6
bundis = bundles to be displayed (1 to 5, with one repeated)
bundif = location of repeated bundle identifier (so that all 5
         may be verified)

TEST: #SR 3 6 20 24
      "Immediately after <open workstation>, the first five
       defined polyline bundles of the WSL should appear as
       specified in the corresponding predefined polyline
       bundles of the WDT."

The actual results (polylines drawn from initial state of WSL)
are drawn on the left side of the picture. The corresponding
expected results (polyline with individual attributes taken
from WDT) are drawn on the right side, except for one
polyline which will be different.

display and label actual results from bundis.

set linetype, linewidth and color index ASF to individual

for ix = 1, numbun
   <inquire predefined polyline representation> on index
        bundis(ix), determine:
      pdlt = predefined linetype
      pdlw = predefined linewidth scale factor
      pdci = predefined polyline color index
    if (ix = bundif) then
       pdlt = (pdlt mod 4) + 1
       pdlw = pdlw * 1.25
       pdci = (pdci mod 5) + 1
    endif
    draw polyline with pdlt, pdlw, pdci
next ix

OPQA/WORKSTATION DESCRIPTION AND STATE LIST TABLES, INDICES 1-5:
   Which pair of lines does NOT match?
pass/fail depending on (operator selects bundif)

*** *** ***   predefined polyline bundles > 5

if nprei <= 5 then
   skip to end_comp_tables
endif

numbun = min (8, nprei-5)
bundis = distinct bundles to be displayed - randomly chosen
         from [6,nprei] predefined bundles

TEST: #SR 3 6 20 24
      "Immediately after <open workstation>, the defined
       polyline bundles > 5 of the WSL should appear as
       specified in the corresponding predefined polyline
       bundles of the WDT."

The actual results (polylines drawn from initial state of WSL)
are drawn on the left side of the picture. The corresponding
expected results (polyline with individual attributes copied
from WDT) are drawn on the right side, except for one
polyline which will be different.

display and label bundis

bundif = randomly selected bundle from bundis
set linetype, linewidth and color index ASF to individual

for ix = 1, numbun
   <inquire predefined polyline representation> on index
        bundis(ix), determine
      pdlt = predefined linetype
      pdlw = predefined linewidth scale factor
      pdci = predefined polyline color index
    if (ix = bundif) then
       pdlt = (pdlt mod 4) + 1
       pdlw = pdlw * 1.25
       pdci = (pdci mod 5) + 1
    endif
    draw polyline with pdlt, pdlw, pdci
next ix

OPQA/WORKSTATION DESCRIPTION AND STATE LIST TABLES, INDICES > 5:
   Which pair of lines does NOT match?
pass/fail depending on (operator selects bundif)

end_comp_tables:

*** ***  predefined bundle descriptions   *** ***

TEST: #SR 3 6 20
      "The appearance of predefined polyline bundles should agree
       with the descriptions supplied by the implementor."

numbun = min(8, nprei)
bundis = distinct bundles to be displayed, sorted

for ix = 1 to numbun
   <inquire predefined polyline representation> for index ix, determine
      pdlt = linetype
      pdlw = linewidth scale factor
      pdci = polyline color index
   display and label ixth entry in bundis and its pdlt, pdlw, pdci
next ix

OPQA/PREDEFINED POLYLINE BUNDLES: Does the appearance of each
  polyline agree with the displayed aspect values for that bundle?
if (operator responds "yes") then
   OPQA/PREDEFINED POLYLINE BUNDLES: If the implementor provides
      external documentation, is it consistent with the polyline
      appearance and displayed aspect values for every bundle
      identifier?
   pass/fail depending on (operator responds "yes")
else
   fail
endif

END PROGRAM 9


PROGRAM 10: Polyline bundle index

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

DEFINED POLYLINE INDICES: All lines but one are identical (drawn
with the same attributes).  Identify the line that is different.

UNDEFINED POLYLINE INDICES: A star is drawn with several
horizontal lines beneath it.  Normally, all of these will have
the same attributes as the star.  Count up and report the number
of lines which match the star in linetype, linewidth, and color.

DESIGN:

set all ASFs to BUNDLED

<inquire workstation state table lengths> to determine maximum
   number of entries in polyline table
szbt   = maximum size of bundle table

*** *** ***   polyline index

TEST: #SR 3 4 5 6
      "A defined polyline index should cause the addressed
       entry in the bundle table to be used when rendering a
       polyline."

bundis = number of bundles to be displayed = min(8, szbt)
initialize all of bundis to: linetype 1,
                             linewidth scale factor 1.0,
                             color index 1

bundif = randomly selected bundle from bundis
set bundif = linetype   = 2
             linewidth scale factor  = 2.0
             color      = 2

Display and label a polyline for each bundle in bundis

OPQA/DEFINED POLYLINE INDICES: which line is different?
pass/fail depending on (line with attributes from bundle #bundif
                        selected)

TEST: #SR 3 4 5 7
      "An undefined polyline index should cause bundle number 1
       in the polyline bundle table to be used when rendering a
       polyline."

set index #1 in bundle table to linetype   = 2
                                linewidth  = 2.0
                                line color = 2

u1,u2,u3 = 3 undefined, positive indices - all greater than
  maximum defined index in bundle table (szbt)
explct = number of explicit lines using bundle #1 = random integer
   from 0 to 4

draw star with bundle index 1

display interleaved:
  three lines using bundle index u1,u2,u3,
  explct lines using bundle index 1

OPQA/UNDEFINED POLYLINE INDICES: How many of the horizontal
  lines have the same attributes as the star?
pass/fail depending on response = 3+explct

END PROGRAM 10


PROGRAM 11: Appearance of bundled attributes

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

MANDATORY LINETYPES: This screen should display examples of each
of the mandatory linetypes actually supported by the
implementation.  You should not consider whether all 4 are
present, but simply whether each linestyle is recognizable from
the verbal description.  Enter a list of integers which identify
the linetypes in the same order as they appear in the prompt.

NON-MANDATORY REGISTERED LINETYPES: This screen displays a sample
of supported registered linetypes (at most 8).  For each
displayed line, look up its linetype identifier in the ISO
register and verify that the actual appearance of the line agrees
with the ISO specification.

IMPLEMENTOR DEFINED LINETYPES: This screen displays a sample of
implementor defined linetypes (at most 8).  For each displayed
line, look up its linetype identifier in the implementor's
documentation and verify that the actual appearance of the line
agrees with the specification.

VARIOUS LINEWIDTH SCALE FACTORS: Several numbered pairs of
rectangles are drawn.  Compare the vertical sizes for each pair.
One pair should have the same size for both members.  Although
the program tries to line up the bottom of the rectangles, there
is no requirement that they be aligned, so judge only according
to size.

POSITIVE LINEWIDTH BELOW MINIMUM: as above, for VARIOUS LINEWIDTH
SCALE FACTORS.

NEGATIVE LINEWIDTH: as above, for VARIOUS LINEWIDTH SCALE
FACTORS.

POSITIVE LINEWIDTH ABOVE MAXIMUM: as above, for VARIOUS LINEWIDTH
SCALE FACTORS.

DEFINED POLYLINE COLOR INDICES: All lines but one are drawn in
the background color.  Identify the single line drawn in the
default foreground color.

UNDEFINED POLYLINE COLOR INDICES: A star is drawn with several
horizontal lines beneath it.  Normally, all of these will be the
same color as the star.  Count up and report the number of lines
which match the star in color.

DESIGN:

set all ASFs to BUNDLED

use <inquire polyline facilities> to determine:
  numlt  = number of available linetypes
  lavslt = list of available standard linetypes
  lavrlt = list of available registered (non-mandatory) linetypes
  lavilt = list of available implementor-defined linetypes
           (may be derived directly from linetype value, if reported
            number of linetypes < 0)
  numlw  = number of available line-widths
  nomlw  = nominal line-width (DC)
  minlw,maxlw = minimum,maximum line-width (DC)

use <inquire workstation state table lengths> to determine:
   szbt = size of polyline bundle table


*** *** ***   linetype

Use default background color=0, foreground=1

stddx = size of lavslt

for ix = 1, stddx
   <set polyline representation>:
      index     = ix
      linetype  = ixth entry in lavslt
      linewidth = 1.0
      color     = 1
next ix

Display in random order bundles 1 thru stddx

TEST: #SR 3 4 5 6 35 36
      "The mandatory linetypes (1-4) should be recognizable from
       their standard description."

OPQA/MANDATORY LINETYPES: List, in order, the numeric labels for
  linetypes: solid, dotted, dashed, dotted-dashed.

pass/fail depending on (all displayed linetypes correctly identified)

regdx = size of lavrlt
if regdx < 1 skip to neg_type

numdis = min(regdx, 8, szbt)
lindis = numdis entries, randomly chosen from lavrlt

for ix = 1, numdis
   <set polyline representation>:
      index     = ix
      linetype  = ixth entry in lindis
      linewidth = 1.0
      color     = 1
next ix

display in order and label bundles 1 thru numdis

TEST: #SR 3 4 5 6 35 37
      "The registered non-mandatory linetypes (> 4) should agree
       with their registered description."

OPQA/NON-MANDATORY REGISTERED LINETYPES: Is each linetype
  depicted according to its numeric identifier's specification in
  the ISO register?
pass/fail depending on (operator responds "yes")

neg_type:

impdx = size of lavilt
if impdx < 1 goto end_linetype

numdis = min(impdx, 8, szbt)
lindis = numdis entries, randomly chosen from lavilt

for ix = 1, numdis
   <set polyline representation>:
      index     = ix
      linetype  = ixth entry in lindis
      linewidth = 1.0
      color     = 1
next ix

display in order and label bundles 1 thru numdis

TEST: #SR 3 4 5 6 35 38
      "Implementor-defined linetypes (< 1) should agree with the
       descriptions supplied by the implementor."

OPQA/IMPLEMENTOR DEFINED LINETYPES: Is each linetype depicted
  according to its numeric identifier's specification in the
  implementor documentation?
pass/fail depending on (operator responds "yes")

end_linetype:

*** *** ***   line-width

from dialog common:
  wcpdc  = WC unit / DC unit
  qvis   = minimum distinguishable length in DC-units

Are there at least two visually distinguishable line-widths?
if (numlw = 1)              or
   (maxlw <= 1.02 * minlw)  or
   (maxlw-minlw < qvis)    then
   only one distinguishable:
   tstlw1 = first linewidth to be tested = maxlw
   tstlw2 =  last linewidth to be tested = tstlw1
   mult = 2
else
   tstlw1 = first linewidth to be tested = minlw
   tstlw2 =  last linewidth to be tested = maxlw
   if (numlw = 0) then
      continuous range of linewidths available - take 4 geometric steps
      mult = 0.9999 * ((tstlw2/tstlw1) ** 0.25)
   else
      discrete set of linewidths available - test min/max only
      mult = 0.9999 * (tstlw2/tstlw1)
   endif
endif

numpas = 0 = number of tests passed so far
thislw = tstlw1

loop thru various linewidths
next_lw:
OPQA/VARIOUS LINEWIDTH SCALE FACTORS: invoke SHPLBW subroutine to
  test bundle with requested line width = thislw
                    expected line width = thislw
if abort indicated
   if (numpas < 2) then
      message about linewidth too big for the screen
      goto min_max_coerce
   else
      goto do_test_msg
   endif
elseif failure indicated
   numpas = 0
   goto do_test_msg
endif

numpas = numpas+1
set up for next linewidth to be tested:
thislw = thislw * mult
if thislw <= tstlw2 goto next_lw

do_test_msg:

TEST: #SR 3 4 5 6 42 43 44
      "Available linewidth scale factors should control the
       realized thickness of a polyline."
pass/fail depending on (numpas > 0)

min_max_coerce:

TEST: #SR 3 4 5 6 42 43 45
      "A requested positive linewidth scale factor below the
       minimum available should be realized as the minimum."
OPQA/POSITIVE LINEWIDTH BELOW MINIMUM: invoke subroutine SHPLBW
  to test bundle with requested line width = minlw/2
                       expected line width = minlw
pass/fail depending on return code from SHPLBW

TEST: #SR 3 4 5 6 42 43 45
      "A requested negative linewidth scale factor should be
       realized as the minimum."
OPQA/NEGATIVE LINEWIDTH: invoke subroutine SHPLBW to test
  bundle with requested line width = -maxlw-100
               expected line width = minlw
pass/fail depending on return code from SHPLBW

OPQA/POSITIVE LINEWIDTH ABOVE MAXIMUM: invoke subroutine SHPLBW
  to test requested line width = maxlw*2
           expected line width = maxlw
if abort indicated
   message about line width too big for the screen
else
   TEST: #SR 3 4 5 6 42 43 45
         "A requested linewidth scale factor above the maximum
          available should be realized as the maximum."
   pass/fail depending on return code from SHPLBW
endif

*** *** ***   polyline color index

TEST: #SR 3 4 5 6 46 47 48
      "A defined polyline color index should cause the addressed
       entry in the color table to be used when rendering a
       polyline."

bckcol = background color = realized color spec for entry #0
forcol = foreground color = realized color spec for entry #1

szcolt = maximum size of color table (including entry #0)
numdis = number of lines to be drawn = min(8, szcolt, szbt)
lncol  = random permutation of #0,#1, and numdis-2 random choices
         from entries #2 to #szcolt-1
visdx = from lncol, randomly select an entry to be made visible
        but not the one that contains 0, since this may not be
        re-settable.

for ix = 1 to numdis
   set entry lncol(ix) in color table to bckcol
   <set polyline representation>:
      index     = ix
      linetype  = 1
      linewidth = 1.0
      color     = lncol(ix)
next ix

set entry lncol(visdx) in color table to forcol

Display bundles 1 thru numdis and label them

OPQA/DEFINED POLYLINE COLOR INDICES: which line is visible?
pass/fail depending on (response = line colored by visdx)

end_def_col:

TEST: #SR 3 4 5 6 46 47 49
      "An undefined polyline color index should cause entry
       number 1 in the color table to be used when rendering a
       polyline."

set entry #1 in color table opposite from BCKCOL
set entry #1 different from FORCOL - make sure undefined default
  to *current* color-rep of #1, not just a predefined color.

explct = number of explicit lines of color #1 = random integer
   from 0 to min(4, szbt-3)
u1,u2,u3 = 3 undefined, positive color indices - all greater
  than maximum defined entry in color table

draw star with color #1

set up bundles 1 thru 3 to linestyle=1, width=1, color index= undf(1,2,3)
set up bundles 4 thru (explct+3) to linestyle=1, width=1, color index=1

display in random order bundles #1 thru explct+3

OPQA/UNDEFINED POLYLINE COLOR INDICES: how many lines are the
  same color as the star?
pass/fail depending on response = 3+explct

END PROGRAM 11


PROGRAM 12: Network inheritance and initialization of polyline
            index

CHARACTERISTICS: ynny

OPERATOR SCRIPT:

STRUCTURE NETWORK INHERITANCE FOR POLYLINE INDEX: This screen
displays several left-right pairs of polylines.  Make sure that
all pairs except one have matching linestyles, linewidths, and
colors.  Identify the non-matching pair.

DESIGN:

All test cases use same basic structure network for testing
inheritance.  Five (distinct if possible) values for the
attribute to be tested are set up and propagated throughout the
network.  The first value is the system default from the PDT.
Note that structure #104 is executed by both #103 and #101.
Actual results are displayed on the left, expected results
on the right, with the 14th deliberately made incorrect.

default = val#1
  |                  102
  |                 /  prim 2
  |               /    attr = val#3   val#3
  V        val#1/      exec 103---------------103
101           /        prim 8                   prim 3
  prim 1    /                                   attr = val#4
  exec 102/                                     prim 4
  prim 9                                        exec 104\
  attr = val#2                                  prim 7    \ val#4
  prim 10                                                   \
  transform             val#2                                 \
  exec 104-----------------------------------------------------104
  un-transform                                                   prim 5/11
  prim 13                                                        attr = val#5
  prim 14                                                        prim 6/12
  exec 105---------->105
                       expected values

*** *** ***   inheritance for polyline index *** *** ***

use <inquire polyline facilities> to determine:
  numlt  = number of linetypes
  numlw  = number of available line-widths
  nomlw  = nominal line-width (DC)
  minlw,maxlw = minimum,maximum line-width (DC)

get 5 linetype values:
llntyp = list of 5 (possible repeated) selected linetypes

get alternative linewidth values:

altlw1 should not exceed .05 (WC) to avoid overlap - distance
  between lines will be 1/15 = .06666
altlw1 = min(max scale factor, factor equivalent to .05 in WC)
altlw2 = min scale factor

if default (1.0) is near altlw1 or altlw2, set alternate so as to
maximize the smallest gap among altlw1, altlw2, and 1.0:

avg1 = (altlw1 + 1) / 2
avg2 = (altlw2 + 1) / 2
if (abs(altlw1-1) < abs(avg2-1)) then
   altlw1 = avg2
elseif (abs(altlw2-1) < abs(avg1-1)) then
   altlw2 = avg1
endif

call DISCOL to try to get 5 distinct foreground colors,
  returning fcol = actual number of foreground colors
colind[1..5] = [1,2,3,4,5]
if (fcol < 5) then
   copy 1st valid part of list to tail of list
endif

set up bundles 1-5

   bundle
   index     linetype    linewidth    color index
   ------    --------    ---------    -----------
     1       llntyp(1)     1.0        colind(1)
     2       llntyp(2)     altlw1     colind(2)
     3       llntyp(3)     altlw2     colind(3)
     4       llntyp(4)     altlw1     colind(4)
     5       llntyp(5)     altlw2     colind(5)

randomize location of polylines
set up CSS as described above
set all ASFs to BUNDLED

display 14 pairs of polylines, using bundles 1-5

TEST: #SR 3 5 6 8 9
      "The polyline index should be saved and restored by
       <execute structure> during traversal."

OPQA/STRUCTURE NETWORK INHERITANCE FOR POLYLINE INDEX:
  which pair of lines does NOT match?
pass/fail depending on response = position of polyline 14

END PROGRAM 12

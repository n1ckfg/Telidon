      SUBROUTINE TSTERR (EXPFUN, CONDES, ERLOGT)

C  TSTERR sets up one test case for error handling and then issues
C  pass or fail for it.  It sets up the test case based on the SRs
C  to be tested (ERRSRS), the list of expected errors (EXPERR) and
C  the expected error-generating function (EXPFUN).  The test
C  procedure adopted depends on whether TSTERR is invoked for
C  user-defined error handling, or system-defined, as indicated by
C  USRERR.
C
C  Input parameters:
C    EXPFUN : code for the expected generating function.
C    CONDES : description of condition that should have caused error
C    ERLOGT : content of error message serving as terminator

      COMMON /GLOBNU/ CTLHND, ERRSIG, ERRFIL, IERRCT, UNERR,
     1        TESTCT, IFLERR, PASSSW, ERRSW,  MAXLIN,
     2        CONID, MEMUN, WKID, WTYPE,GLBLUN, INDLUN,
     3        DUMINT, DUMRL
      INTEGER         CTLHND, ERRSIG, ERRFIL, IERRCT, UNERR,
     1        TESTCT, IFLERR, PASSSW, ERRSW,  MAXLIN,
     2        CONID, MEMUN, WKID, WTYPE,GLBLUN, INDLUN,
     3        DUMINT(20), ERRIND
      REAL   DUMRL(20)

      COMMON /GLOBCH/ PIDENT,    GLBERR,    TSTMSG,     FUNCID,
     1                DUMCH
      CHARACTER       PIDENT*40, GLBERR*60, TSTMSG*900, FUNCID*80,
     1                DUMCH(20)*20

      COMMON /ERRINF/ ERRCOM,FUNCOM,FILCOM, ERNMSW, EXPSIZ,EXPERR,
     1                USRERR, ERRSAV,      FUNSAV,      FILSAV,
     2                EFCNT, EFID
      INTEGER         ERRCOM,FUNCOM,FILCOM, ERNMSW, EXPSIZ,EXPERR(10),
     1                USRERR, ERRSAV(200), FUNSAV(200), FILSAV(200),
     2                EFCNT, EFID(100)
      COMMON /ERRCHR/ CURCON,     ERRSRS,    ERRMRK,    ERFLNM,
     1                CONTAB
      CHARACTER       CURCON*200, ERRSRS*40, ERRMRK*20, ERFLNM*80,
     1                CONTAB(40)*150

C  special strings to control processing of error file
      CHARACTER  EOFMRK*17,                    BOFMRK*10
      PARAMETER (EOFMRK = 'end of error file', BOFMRK = 'first call')

C  for user error handling, ERRCT is used to scan through array
C  of actual results generated by error-signalling functions
      SAVE ERRCT

      INTEGER    EESC,       EPREC,      EUREC
      PARAMETER (EESC  =180, EPREC =181, EUREC =182 )

      INTEGER    EXPFUN, GENERR, GENFUN, IERR, ERRCT, TSTAT
      INTEGER    IX, LST, LNB, ITRIM, LEADNB, IARFND

      LOGICAL    ERROK, FUNOK, FILOK

      CHARACTER  ACODE*4, TMSG*500, ANS*1, MSG*160, ERLOGT*(*)
      CHARACTER  FUNNAM*80, ERRMSG*180, FUNMSG*80, EMSG*1000
      CHARACTER  CONDES*(*)

      DATA ERRCT  / 0 /
      DATA EMSG   / BOFMRK /

C  set up test message
      CALL ERFUNM (EXPFUN, FUNNAM)
      TMSG = 'If ' // FUNNAM
      TMSG(ITRIM(TMSG)+2:) = 'is called and ' // CONDES
      TMSG(ITRIM(TMSG)+1:) = ', it should'

      IF (USRERR.EQ.1 .OR. USRERR.EQ.3) THEN
         IF (EXPSIZ.LT.1) THEN
            CALL UNMSG ('TSTERR called with invalid EXPSIZ.')
         ENDIF
         TMSG(ITRIM(TMSG)+2:) = 'return error code'
C  may be several valid error code possibilities
         DO 20 IX = 1, EXPSIZ-1
            WRITE (ACODE, '(I4.3)') EXPERR(IX)
            TMSG(ITRIM(TMSG)+2:) = ACODE // ','
20       CONTINUE
         IF (EXPSIZ.GE.2) TMSG(ITRIM(TMSG):) = ' and/or'
         WRITE (ACODE, '(I4.3)') EXPERR(EXPSIZ)
         TMSG(ITRIM(TMSG)+2:) = ACODE
         WRITE (ACODE, '(I4.3)') EXPFUN

         IF (USRERR.EQ.1) THEN
            TMSG(ITRIM(TMSG)+1:) = ', function identifier ' // ACODE //
     1           ', and the current error file identifier'
         ELSE
            TMSG(ITRIM(TMSG)+2:) = 'and function identifier ' // ACODE
         ENDIF

         TMSG(ITRIM(TMSG)+2:) = 'to the user defined error handler.'
      ELSEIF (USRERR.EQ.2) THEN
         TMSG(ITRIM(TMSG)+2:) = 'write an accurate, ' //
     1       'self-identifying error message on the error file.'
      ELSEIF (USRERR.EQ.4) THEN
         CALL UNMSG ('TSTERR called with USRERR=4.')
         TMSG(ITRIM(TMSG)+2:) = 'write an accurate, ' //
     1       'self-identifying error message to the operator.'
      ELSEIF (USRERR.EQ.5) THEN
         TMSG = CONDES
      ELSE
         CALL UNMSG ('TSTERR detected an invalid value for USRERR.')
      ENDIF

      CALL SETMSG (ERRSRS, TMSG)

C  use this to make sure that error handler was called at least once:
C  for TSTAT, -1:fail, 0:pass, 1:no test yet
      TSTAT = 1

      IF (USRERR.EQ.1 .OR. USRERR.EQ.3) THEN
         GOTO 100
      ELSE
         GOTO 150
      ENDIF

C  *** *** *** ***   user-defined error handling   *** *** *** ***
100   CONTINUE
C  loop thru and make sure all entries are valid

C  get next actual error result
      ERRCT = ERRCT + 1
      IF (ERRCT.GT.200) THEN
         CALL UNMSG ('TSTERR tried to read past last entry in ' //
     1               'internal table of generated errors.')
      ENDIF
      ERRCOM = ERRSAV(ERRCT)
      FUNCOM = FUNSAV(ERRCT)
      FILCOM = FILSAV(ERRCT)

C  check if no more entries in this group
      IF (ERRCOM.EQ.2 .AND. FUNCOM.EQ.EESC .AND. FILCOM.EQ.-666) THEN
         IF (TSTAT.EQ.0) THEN
            CALL PASS
         ELSEIF (TSTAT.EQ.1) THEN
            CALL FAIL
            CALL INMSG ('Tested function apparently did not call ' //
     1                  'user defined error handling subroutine.')
         ENDIF
         GOTO 999
      ENDIF

C  determine validity of actual error report
      ERROK = IARFND(ERRCOM, EXPSIZ, EXPERR) .GT. 0
      FUNOK = FUNCOM.EQ.EXPFUN
C  no checking of error file when PHIGS is closed at time of error generation
      FILOK = FILCOM.EQ.ERRFIL .OR. USRERR.EQ.3

C  OK so far?
      IF (ERROK .AND. FUNOK .AND. FILOK) THEN
         TSTAT = MIN(TSTAT, 0)
         GOTO 100
      ENDIF

      IF (TSTAT .GE. 0) THEN
C  first detected failure condition
         CALL FAIL
         TSTAT = -1
      ENDIF

      IF (.NOT. ERROK) THEN
         WRITE (MSG, '(A,I6.3,A)') 'Reported error number ', ERRCOM,
     1               ' is not one of the expected values.'
         CALL INMSG (MSG)
      ENDIF

      IF (.NOT. FUNOK) THEN
         WRITE (MSG, '(A,I4.3,A,I4.3,A)') 'Reported function ' //
     1          'identifier ', FUNCOM, ' does not match '      //
     2          'expected function identifier ', EXPFUN, '.'
         CALL INMSG (MSG)
      ENDIF

      IF (.NOT. FILOK) THEN
         WRITE (MSG, '(A,I4.3,A,I4.3,A)') 'Reported error file ' //
     1          'identifier ', FILCOM, ' does not match '        //
     2          'expected error file identifier ', ERRFIL, '.'
         CALL INMSG (MSG)
      ENDIF

      GOTO 100

C  *** *** *** ***   system-defined error handling   *** *** *** ***
150   CONTINUE
C  loop thru and make sure all error file messages are valid

      CALL GTERRM (ERRFIL, EMSG)
C  check if no more entries
      IF (EMSG.EQ.EOFMRK .OR.
     1    EMSG(LEADNB(EMSG):ITRIM(EMSG)).EQ.ERLOGT) THEN
         IF (TSTAT.EQ.0) THEN
            CALL PASS
         ELSEIF (TSTAT.EQ.1) THEN
            CALL FAIL
            CALL INMSG ('Tested function apparently did not call ' //
     1                  'system defined error handling subroutine.')
         ENDIF
         GOTO 999
      ENDIF

      CALL OPMSG (' ')
      CALL OPMSG ('------- Begin error message -------')
      CALL OPMSG (EMSG)
      CALL OPMSG ('------- End error message -------')
      CALL OPMSG (' ')

C  determine validity of actual error report
      CALL OPMSG ('Based on the error message, which function '   //
     1            'caused the error?  Enter either generic name ' //
     1            'in lower case, or numeric function code from ' //
     1            'Fortran binding.  Enter a negative number if ' //
     1            'function cannot be determined from the message.')

550   CONTINUE
      CALL OPLIN (FUNMSG)
      LNB = LEADNB (FUNMSG)
      LST = ITRIM  (FUNMSG)
      CALL PRSINT (FUNMSG(LNB:LST), GENFUN, IERR)
      IF (IERR.EQ.0) THEN
C        integer response from operator - GENFUN set
      ELSE
C  string response from operator
         CALL ERFUCD (FUNMSG, GENFUN)
         IF (GENFUN .LT. 0) THEN
            CALL OPMSG ('Could not find the function you typed, ' //
     1                  'try again.')
            GOTO 550
         ENDIF
      ENDIF

C  GENFUN is now set
      FUNOK = GENFUN .EQ. EXPFUN

600   CONTINUE
      CALL OPMSG ('If the error message indicates the numeric ' //
     1            'error code, enter it; otherwise type "n".')
      CALL OPLIN (FUNMSG)
      IF (FUNMSG .EQ. 'n') GOTO 610

      LNB = LEADNB (FUNMSG)
      LST = ITRIM  (FUNMSG)
      CALL PRSINT (FUNMSG(LNB:LST), GENERR, IERR)
      IF (IERR .NE. 0) THEN
         CALL OPMSG ('Invalid reply; re-enter.')
         GOTO 600
      ENDIF

C  Explicit error code in message
      ERROK = IARFND(GENERR, EXPSIZ, EXPERR) .GT. 0
      GOTO 690

C  No explicit error code in message
610   CONTINUE
      IF (EXPSIZ.GT.1) THEN
         CALL OPMSG ('Here are the standard error messages ' //
     1               'for the valid error codes:')
      ELSE
         CALL OPMSG ('Here is the standard message wording:')
      ENDIF

      CALL OPMSG ('------- Begin standard wording -------')
      DO 50 IX = 1,EXPSIZ
         CALL SCHERR (EXPERR(IX), ERRMSG)
         CALL OPMSG (ERRMSG)
         IF (IX.LT.EXPSIZ) THEN
            CALL OPMSG ('-----------')
         ELSE
            CALL OPMSG ('------- End standard wording -------')
         ENDIF
50    CONTINUE

      CALL OPYN ('Does the meaning of the actual message ' //
     1           'match (one of) the standard message(s)?', ANS)
      ERROK = ANS.EQ.'y'

690   CONTINUE
C  OK so far?
      IF (ERROK .AND. FUNOK) THEN
         TSTAT = MIN(TSTAT, 0)
         GOTO 150
      ENDIF

      IF (TSTAT .GE. 0) THEN
C  first detected failure condition
         CALL FAIL
         TSTAT = -1
      ENDIF

      IF (.NOT. ERROK) THEN
         IF (FUNMSG .EQ. 'n') THEN
            CALL INMSG ('Incorrect description of error condition ' //
     1                  'in error message.')
         ELSE
            WRITE (MSG, '(A,I6.3,A)') 'Reported error number ', GENERR,
     1                  ' is not one of the expected values.'
            CALL INMSG (MSG)
         ENDIF
      ENDIF

      IF (.NOT. FUNOK) THEN
         IF (GENFUN.LT.0) THEN
            CALL INMSG ('Missing function identifier in error message.')
         ELSE
            WRITE (MSG, '(A,I4.3,A,I4.3,A)') 'Reported function ' //
     1             'identifier ', GENFUN, ' does not match '      //
     2             'expected function identifier ', EXPFUN, '.'
            CALL INMSG (MSG)
         ENDIF
      ENDIF
      GOTO 150

999   CONTINUE

      END

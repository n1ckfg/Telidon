<!DOCTYPE html>
<html>
	
	<head>
		<script src="../../../js/libraries/p5js/p5.min.js"></script>
		<script src="../../../js/libraries/p5js/p5.svg.js"></script>
		<script src="../../../js/telidon/naplps.js"></script>
	</head>

	<body>
		<script>
			"use strict";

			let pg, ps, polylines, polygons;
			let input = [];
			let offsetX = 0;
			let offsetY = 240;

			function preload() {
				ps = loadSVG("test2.svg");
			}

			function setup() {
				createCanvas(400, 400);
				pg = createGraphics(width, height, SVG);
				
				pg.push();
				pg.image(ps, 0, 0);
			    pg.pop();

			    let polygons = pg.querySVG('polygon');
			    let polylines = pg.querySVG('polyline');

		    	// NAPLPS can only use a fill color or a stroke color in one path, not both.
				// fill-opacity, stroke-opacity, stroke-linecap, and stroke-width are not used.
				
			    for (let path of polygons) {
			    	let points = [];
			    	let color = new Vector3(255, 255, 255);
			    	let isFill = true;
			    	
					let strokeColorAttr = path.attribute("stroke"); // "#FEFEFE" or "none" 
			    	let fillColorAttr = path.attribute("fill"); // "#FEFEFE" or "none" 			
					
					if (fillColorAttr !== "none") {
						let colorHex = hexToRgb(fillColorAttr);
						color = new Vector3(colorHex.r, colorHex.g, colorHex.b);
					} else if (fillColorAttr === "none" && strokeColorAttr !== "none") {
						let colorHex = hexToRgb(strokeColorAttr);
						color = new Vector3(colorHex.r, colorHex.g, colorHex.b);
					}

			    	let pointsAttr = path.attribute("points").split(" ");
			    	for (let pointAttr of pointsAttr) {
			    		let pointAttrArray = pointAttr.split(",");
			    		let point = new Vector2(float(pointAttrArray[0]) + offsetX, float(pointAttrArray[1]) + offsetY);
			    		points.push(point);
			    	}
					
					const stroke = new NapInputWrapper(color, points, isFill);
					input.push(stroke);
			    }

			    for (let path of polylines) {
			    	let points = [];
			    	let color = new Vector3(0, 0, 0);
			    	let isFill = false;
			    	
					let strokeColorAttr = path.attribute("stroke"); // "#FEFEFE" or "none" 
			    	let fillColorAttr = path.attribute("fill"); // "#FEFEFE" or "none" 
					
					if (strokeColorAttr === "none" && fillColorAttr !== "none") {
						let colorHex = hexToRgb(fillColorAttr);
						color = new Vector3(colorHex.r, colorHex.g, colorHex.b);
					} else if (strokeColorAttr !== "none") {
						let colorHex = hexToRgb(strokeColorAttr);
						color = new Vector3(colorHex.r, colorHex.g, colorHex.b);
					}

			    	let pointsAttr = path.attribute("points").split(" ");
			    	for (let pointAttr of pointsAttr) {
			    		let pointAttrArray = pointAttr.split(",");
			    		let point = new Vector2(float(pointAttrArray[0]) + offsetX, float(pointAttrArray[1]) + offsetY);
			    		points.push(point);
			    	}
					
					const stroke = new NapInputWrapper(color, points, isFill);
					input.push(stroke);
			    }

				const encoder = new NapEncoder(input, 1, 0.75);

				document.body.appendChild(document.createElement("br"));
				document.body.appendChild(document.createElement("br"));
				const div = document.createElement("div");
				document.body.appendChild(div);
				div.innerHTML = encoder.napRaw;				
			}

			function draw() {
				background(63);
				image(pg, 0, 0);
			}

			function hexToRgb(hex) {
				let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result ? {
					r: parseInt(result[1], 16),
					g: parseInt(result[2], 16),
					b: parseInt(result[3], 16)
				} : null;
			}

			function componentToHex(c) {
			  let hex = c.toString(16);
			  return hex.length == 1 ? "0" + hex : hex;
			}

			function rgbToHex(r, g, b) {
			  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
			}
		</script>
	</body>

</html>